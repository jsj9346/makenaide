"""
ÏãúÏû• Ï≤¥Ïò®Í≥Ñ(Market Thermometer) Î™®Îìà

üéØ ÌïµÏã¨ Í∏∞Îä•:
- 4Í∞ú ÌïµÏã¨ ÏßÄÌëúÎ°ú ÏãúÏû• Î∂ÑÏúÑÍ∏∞ Îπ†Î•∏ ÌååÏïÖ
- ÌååÏù¥ÌîÑÎùºÏù∏ ÏßÑÏûÖ Ïó¨Î∂Ä Í≤∞Ï†ï
- Í≤ΩÎüâÌôîÎêú ÏãúÏû• Î∂ÑÏÑù

üìä ÏßÄÌëú Íµ¨ÏÑ±:
1. Îì±ÎùΩÎ•† Î∂ÑÌè¨ (pct_up, pct_down)
2. Í±∞ÎûòÎåÄÍ∏à ÏÉÅÏúÑ 10Í∞ú ÏßëÏ§ëÎèÑ (top10_volume_ratio)  
3. MA200 ÏÉÅÌöå ÎπÑÏú® (ma200_above_ratio)
"""

import pandas as pd
import numpy as np
from typing import Dict, Optional, Tuple
from db_manager import get_db_manager
import logging
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv

# ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎî©
load_dotenv()

# Î°úÍπÖ ÏÑ§Ï†ï
logger = logging.getLogger(__name__)

class MarketThermometer:
    """ÏãúÏû• Ï≤¥Ïò®Í≥Ñ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        self.db_manager = get_db_manager()
        self.thresholds = self._load_thresholds_from_config()
        logger.info("üå°Ô∏è ÏãúÏû• Ï≤¥Ïò®Í≥Ñ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        logger.info(f"   - ÏûÑÍ≥ÑÍ∞í: {self.thresholds}")
    
    def _load_thresholds_from_config(self) -> Dict:
        """ÏÑ§Ï†ï ÌååÏùºÏóêÏÑú ÏûÑÍ≥ÑÍ∞í Î°úÎìú"""
        try:
            import yaml
            current_dir = os.path.dirname(os.path.abspath(__file__))
            config_path = os.path.join(current_dir, 'config', 'filter_rules_config.yaml')
            
            if os.path.exists(config_path):
                with open(config_path, 'r', encoding='utf-8') as file:
                    config = yaml.safe_load(file)
                
                market_thermometer_config = config.get('market_thermometer', {})
                thresholds = market_thermometer_config.get('thresholds', {})
                
                # Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
                default_thresholds = {
                    'min_pct_up': 45.0,
                    'max_top10_volume': 70.0,
                    'min_ma200_above': 25.0,
                    'min_sentiment_score': 60.0
                }
                
                # ÏÑ§Ï†ï ÌååÏùºÏùò Í∞íÏúºÎ°ú Í∏∞Î≥∏Í∞í ÏóÖÎç∞Ïù¥Ìä∏
                for key, value in thresholds.items():
                    if key in default_thresholds:
                        default_thresholds[key] = value
                
                logger.info(f"‚úÖ ÏÑ§Ï†ï ÌååÏùºÏóêÏÑú ÏûÑÍ≥ÑÍ∞í Î°úÎìú ÏôÑÎ£å: {default_thresholds}")
                return default_thresholds
            else:
                logger.warning(f"‚ö†Ô∏è ÏÑ§Ï†ï ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå: {config_path}")
                return {
                    'min_pct_up': 45.0,
                    'max_top10_volume': 70.0,
                    'min_ma200_above': 25.0,
                    'min_sentiment_score': 60.0
                }
                
        except Exception as e:
            logger.error(f"‚ùå ÏÑ§Ï†ï ÌååÏùº Î°úÎìú Ïã§Ìå®: {e}")
            return {
                'min_pct_up': 45.0,
                'max_top10_volume': 70.0,
                'min_ma200_above': 25.0,
                'min_sentiment_score': 60.0
            }
    
    def calculate_market_sentiment_snapshot(self) -> Dict:
        """
        ÏãúÏû• Î∂ÑÏúÑÍ∏∞ Ïä§ÎÉÖÏÉ∑ Í≥ÑÏÇ∞
        
        Returns:
            Dict: {
                'pct_up': float,           # ÏÉÅÏäπ Ï¢ÖÎ™© ÎπÑÏú®
                'pct_down': float,         # ÌïòÎùΩ Ï¢ÖÎ™© ÎπÑÏú®  
                'top10_volume_ratio': float, # ÏÉÅÏúÑ 10Í∞ú Í±∞ÎûòÎåÄÍ∏à ÎπÑÏ§ë
                'ma200_above_ratio': float,  # MA200 ÏÉÅÌöå ÎπÑÏú®
                'sentiment_score': float,    # Ï¢ÖÌï© Ï†êÏàò (0-100)
                'market_condition': str,     # ÏãúÏû• ÏÉÅÌô© (bullish/neutral/bearish)
                'should_proceed': bool       # ÌååÏù¥ÌîÑÎùºÏù∏ ÏßÑÌñâ Ïó¨Î∂Ä
            }
        """
        try:
            logger.info("üå°Ô∏è ÏãúÏû• Î∂ÑÏúÑÍ∏∞ Ïä§ÎÉÖÏÉ∑ Í≥ÑÏÇ∞ ÏãúÏûë")
            
            # 1. Îì±ÎùΩÎ•† Î∂ÑÌè¨ Í≥ÑÏÇ∞
            price_distribution = self._calculate_price_distribution()
            logger.debug(f"Îì±ÎùΩÎ•† Î∂ÑÌè¨: {price_distribution}")
            
            # 2. Í±∞ÎûòÎåÄÍ∏à ÏßëÏ§ëÎèÑ Í≥ÑÏÇ∞  
            volume_concentration = self._calculate_volume_concentration()
            logger.debug(f"Í±∞ÎûòÎåÄÍ∏à ÏßëÏ§ëÎèÑ: {volume_concentration}")
            
            # 3. MA200 ÏÉÅÌöå ÎπÑÏú® Í≥ÑÏÇ∞
            ma200_ratio = self._calculate_ma200_ratio()
            logger.debug(f"MA200 ÏÉÅÌöå ÎπÑÏú®: {ma200_ratio}")
            
            # 4. Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞
            sentiment_score = self._calculate_sentiment_score(
                price_distribution, volume_concentration, ma200_ratio
            )
            logger.debug(f"Ï¢ÖÌï© Ï†êÏàò: {sentiment_score}")
            
            # 5. ÏãúÏû• ÏÉÅÌô© ÌåêÎã®
            market_condition = self._determine_market_condition(sentiment_score)
            
            # 6. ÌååÏù¥ÌîÑÎùºÏù∏ ÏßÑÌñâ Ïó¨Î∂Ä Í≤∞Ï†ï
            should_proceed = self._should_proceed_pipeline(
                price_distribution, volume_concentration, ma200_ratio, sentiment_score
            )
            
            result = {
                'pct_up': price_distribution['pct_up'],
                'pct_down': price_distribution['pct_down'],
                'top10_volume_ratio': volume_concentration['top10_ratio'],
                'ma200_above_ratio': ma200_ratio['above_ratio'],
                'sentiment_score': sentiment_score,
                'market_condition': market_condition,
                'should_proceed': should_proceed,
                'timestamp': pd.Timestamp.now(),
                'details': {
                    'price_distribution': price_distribution,
                    'volume_concentration': volume_concentration,
                    'ma200_ratio': ma200_ratio
                }
            }
            
            logger.info(f"üå°Ô∏è ÏãúÏû• Ï≤¥Ïò®Í≥Ñ Í≤∞Í≥º: {result}")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå ÏãúÏû• Î∂ÑÏúÑÍ∏∞ Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return self._get_fallback_result()
    
    def _calculate_price_distribution(self) -> Dict:
        """Îì±ÎùΩÎ•† Î∂ÑÌè¨ Í≥ÑÏÇ∞"""
        try:
            query = """
                WITH latest_data AS (
                    SELECT 
                        ticker,
                        close,
                        date
                    FROM ohlcv 
                    WHERE date = (SELECT MAX(date) FROM ohlcv)
                    AND close IS NOT NULL
                ),
                previous_data AS (
                    SELECT 
                        ticker,
                        close as prev_close,
                        date
                    FROM ohlcv 
                    WHERE date = (SELECT MAX(date) FROM ohlcv WHERE date < (SELECT MAX(date) FROM ohlcv))
                    AND close IS NOT NULL
                )
                SELECT 
                    COUNT(*) as total_tickers,
                    COUNT(CASE WHEN l.close > p.prev_close THEN 1 END) as up_tickers,
                    COUNT(CASE WHEN l.close < p.prev_close THEN 1 END) as down_tickers,
                    COUNT(CASE WHEN l.close = p.prev_close THEN 1 END) as flat_tickers
                FROM latest_data l
                INNER JOIN previous_data p ON l.ticker = p.ticker
            """
            
            result = self.db_manager.execute_query(query, fetchone=True)
            
            if result:
                total, up_count, down_count, flat_count = result
                total = total or 1  # 0ÏúºÎ°ú ÎÇòÎàÑÍ∏∞ Î∞©ÏßÄ
                
                pct_up = (up_count / total) * 100
                pct_down = (down_count / total) * 100
                pct_flat = (flat_count / total) * 100
                
                return {
                    'pct_up': round(pct_up, 1),
                    'pct_down': round(pct_down, 1), 
                    'pct_flat': round(pct_flat, 1),
                    'up_down_ratio': round(pct_up / pct_down, 2) if pct_down > 0 else 999,
                    'total_tickers': total,
                    'up_count': up_count,
                    'down_count': down_count,
                    'flat_count': flat_count
                }
            else:
                logger.warning("‚ö†Ô∏è Îì±ÎùΩÎ•† Î∂ÑÌè¨ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                return {
                    'pct_up': 50.0, 'pct_down': 50.0, 'pct_flat': 0.0, 
                    'up_down_ratio': 1.0, 'total_tickers': 0,
                    'up_count': 0, 'down_count': 0, 'flat_count': 0
                }
                
        except Exception as e:
            logger.error(f"‚ùå Îì±ÎùΩÎ•† Î∂ÑÌè¨ Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return {
                'pct_up': 50.0, 'pct_down': 50.0, 'pct_flat': 0.0, 
                'up_down_ratio': 1.0, 'total_tickers': 0,
                'up_count': 0, 'down_count': 0, 'flat_count': 0
            }
    
    def _calculate_volume_concentration(self) -> Dict:
        """Í±∞ÎûòÎåÄÍ∏à ÏÉÅÏúÑ 10Í∞ú ÏßëÏ§ëÎèÑ Í≥ÑÏÇ∞"""
        try:
            query = """
                SELECT 
                    ticker,
                    volume * close as volume_krw
                FROM ohlcv 
                WHERE date = (SELECT MAX(date) FROM ohlcv)
                AND volume IS NOT NULL AND close IS NOT NULL
                ORDER BY volume * close DESC
                LIMIT 10
            """
            
            top10_data = self.db_manager.execute_query(query)
            
            if top10_data:
                top10_volume = sum(row[1] for row in top10_data if row[1] is not None)
                
                # Ï†ÑÏ≤¥ Í±∞ÎûòÎåÄÍ∏à Í≥ÑÏÇ∞
                total_query = """
                    SELECT SUM(volume * close) as total_volume_krw
                    FROM ohlcv 
                    WHERE date = (SELECT MAX(date) FROM ohlcv)
                    AND volume IS NOT NULL AND close IS NOT NULL
                """
                total_result = self.db_manager.execute_query(total_query, fetchone=True)
                total_volume = total_result[0] if total_result and total_result[0] else 1
                
                top10_ratio = (top10_volume / total_volume) * 100
                
                return {
                    'top10_ratio': round(top10_ratio, 1),
                    'top10_volume': top10_volume,
                    'total_volume': total_volume,
                    'top10_tickers': [row[0] for row in top10_data[:5]]  # ÏÉÅÏúÑ 5Í∞ú Ìã∞Ïª§
                }
            else:
                logger.warning("‚ö†Ô∏è Í±∞ÎûòÎåÄÍ∏à ÏßëÏ§ëÎèÑ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                return {
                    'top10_ratio': 50.0, 'top10_volume': 0, 'total_volume': 0,
                    'top10_tickers': []
                }
                
        except Exception as e:
            logger.error(f"‚ùå Í±∞ÎûòÎåÄÍ∏à ÏßëÏ§ëÎèÑ Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return {
                'top10_ratio': 50.0, 'top10_volume': 0, 'total_volume': 0,
                'top10_tickers': []
            }
    
    def _calculate_ma200_ratio(self) -> Dict:
        """MA200 ÏÉÅÌöå ÎπÑÏú® Í≥ÑÏÇ∞"""
        try:
            query = """
                SELECT 
                    COUNT(*) as total_tickers,
                    COUNT(CASE WHEN close > ma_200 THEN 1 END) as above_ma200
                FROM ohlcv 
                WHERE date = (SELECT MAX(date) FROM ohlcv)
                AND ma_200 IS NOT NULL AND close IS NOT NULL
            """
            
            result = self.db_manager.execute_query(query, fetchone=True)
            
            if result:
                total, above_count = result
                total = total or 1
                
                above_ratio = (above_count / total) * 100
                
                return {
                    'above_ratio': round(above_ratio, 1),
                    'total_tickers': total,
                    'above_count': above_count,
                    'below_count': total - above_count
                }
            else:
                logger.warning("‚ö†Ô∏è MA200 ÏÉÅÌöå ÎπÑÏú® Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                return {
                    'above_ratio': 30.0, 'total_tickers': 0, 
                    'above_count': 0, 'below_count': 0
                }
                
        except Exception as e:
            logger.error(f"‚ùå MA200 ÏÉÅÌöå ÎπÑÏú® Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return {
                'above_ratio': 30.0, 'total_tickers': 0, 
                'above_count': 0, 'below_count': 0
            }
    
    def _calculate_sentiment_score(self, price_dist: Dict, volume_conc: Dict, ma200_ratio: Dict) -> float:
        """Ï¢ÖÌï© ÏãúÏû• Ï†êÏàò Í≥ÑÏÇ∞ (0-100)"""
        try:
            score = 0.0
            
            # 1. Îì±ÎùΩÎ•† Ï†êÏàò (40Ï†ê ÎßåÏ†ê)
            pct_up = price_dist['pct_up']
            if pct_up >= 60:
                score += 40
            elif pct_up >= 55:
                score += 35
            elif pct_up >= 50:
                score += 25
            elif pct_up >= 45:
                score += 15
            else:
                score += 5
            
            # 2. Í±∞ÎûòÎåÄÍ∏à Î∂ÑÏÇ∞ Ï†êÏàò (30Ï†ê ÎßåÏ†ê)
            top10_ratio = volume_conc['top10_ratio']
            if top10_ratio <= 40:
                score += 30  # Î∂ÑÏÇ∞Îêú ÏãúÏû•
            elif top10_ratio <= 50:
                score += 25
            elif top10_ratio <= 60:
                score += 15
            else:
                score += 5   # Í≥ºÎèÑÌïú ÏßëÏ§ë
            
            # 3. MA200 ÏÉÅÌöå Ï†êÏàò (30Ï†ê ÎßåÏ†ê)
            ma200_above = ma200_ratio['above_ratio']
            if ma200_above >= 40:
                score += 30
            elif ma200_above >= 30:
                score += 25
            elif ma200_above >= 20:
                score += 15
            else:
                score += 5
            
            return round(score, 1)
            
        except Exception as e:
            logger.error(f"‚ùå Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 50.0
    
    def _determine_market_condition(self, sentiment_score: float) -> str:
        """ÏãúÏû• ÏÉÅÌô© ÌåêÎã®"""
        if sentiment_score >= 75:
            return 'bullish'
        elif sentiment_score >= 60:
            return 'neutral'
        else:
            return 'bearish'
    
    def _should_proceed_pipeline(self, price_dist: Dict, volume_conc: Dict, 
                                ma200_ratio: Dict, sentiment_score: float) -> bool:
        """ÌååÏù¥ÌîÑÎùºÏù∏ ÏßÑÌñâ Ïó¨Î∂Ä Í≤∞Ï†ï"""
        try:
            # Í∏∞Î≥∏ Ï°∞Í±¥ Ï≤¥ÌÅ¨
            conditions = [
                price_dist['pct_up'] >= self.thresholds['min_pct_up'],
                volume_conc['top10_ratio'] <= self.thresholds['max_top10_volume'],
                ma200_ratio['above_ratio'] >= self.thresholds['min_ma200_above'],
                sentiment_score >= self.thresholds['min_sentiment_score']
            ]
            
            # Î™®Îì† Ï°∞Í±¥ÏùÑ ÎßåÏ°±ÌïòÎ©¥ ÏßÑÌñâ
            should_proceed = all(conditions)
            
            if not should_proceed:
                failed_conditions = []
                if price_dist['pct_up'] < self.thresholds['min_pct_up']:
                    failed_conditions.append(f"ÏÉÅÏäπÏ¢ÖÎ™©ÎπÑÏú®({price_dist['pct_up']}% < {self.thresholds['min_pct_up']}%)")
                if volume_conc['top10_ratio'] > self.thresholds['max_top10_volume']:
                    failed_conditions.append(f"Í±∞ÎûòÎåÄÍ∏àÏßëÏ§ëÎèÑ({volume_conc['top10_ratio']}% > {self.thresholds['max_top10_volume']}%)")
                if ma200_ratio['above_ratio'] < self.thresholds['min_ma200_above']:
                    failed_conditions.append(f"MA200ÏÉÅÌöåÎπÑÏú®({ma200_ratio['above_ratio']}% < {self.thresholds['min_ma200_above']}%)")
                if sentiment_score < self.thresholds['min_sentiment_score']:
                    failed_conditions.append(f"Ï¢ÖÌï©Ï†êÏàò({sentiment_score} < {self.thresholds['min_sentiment_score']})")
                
                logger.warning(f"‚ö†Ô∏è ÏãúÏû• Ï°∞Í±¥ ÎØ∏Ï∂©Ï°±ÏúºÎ°ú ÌååÏù¥ÌîÑÎùºÏù∏ Ï§ëÎã®: {', '.join(failed_conditions)}")
            else:
                logger.info(f"‚úÖ ÏãúÏû• Ï°∞Í±¥ Ï∂©Ï°±, ÌååÏù¥ÌîÑÎùºÏù∏ ÏßÑÌñâ Í∞ÄÎä•")
            
            return should_proceed
            
        except Exception as e:
            logger.error(f"‚ùå ÌååÏù¥ÌîÑÎùºÏù∏ ÏßÑÌñâ Ïó¨Î∂Ä ÌåêÎã® Ïã§Ìå®: {e}")
            return True  # Ïò§Î•ò Ïãú Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏßÑÌñâ
    
    def _get_fallback_result(self) -> Dict:
        """Ïò§Î•ò Ïãú Í∏∞Î≥∏ Í≤∞Í≥º Î∞òÌôò"""
        return {
            'pct_up': 50.0,
            'pct_down': 50.0,
            'top10_volume_ratio': 50.0,
            'ma200_above_ratio': 30.0,
            'sentiment_score': 50.0,
            'market_condition': 'neutral',
            'should_proceed': True,  # Ïò§Î•ò Ïãú Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏßÑÌñâ
            'timestamp': pd.Timestamp.now(),
            'details': {
                'price_distribution': {'pct_up': 50.0, 'pct_down': 50.0},
                'volume_concentration': {'top10_ratio': 50.0},
                'ma200_ratio': {'above_ratio': 30.0}
            }
        }
    
    def update_thresholds(self, new_thresholds: Dict):
        """ÏûÑÍ≥ÑÍ∞í ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            self.thresholds.update(new_thresholds)
            logger.info(f"‚úÖ ÏûÑÍ≥ÑÍ∞í ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å: {new_thresholds}")
        except Exception as e:
            logger.error(f"‚ùå ÏûÑÍ≥ÑÍ∞í ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {e}")
    
    def get_thresholds(self) -> Dict:
        """ÌòÑÏû¨ ÏûÑÍ≥ÑÍ∞í Î∞òÌôò"""
        return self.thresholds.copy()

# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§
market_thermometer = MarketThermometer()

def get_market_sentiment_snapshot() -> Dict:
    """ÏãúÏû• Î∂ÑÏúÑÍ∏∞ Ïä§ÎÉÖÏÉ∑ Î∞òÌôò (Ìé∏Ïùò Ìï®Ïàò)"""
    return market_thermometer.calculate_market_sentiment_snapshot()

def update_market_thermometer_thresholds(new_thresholds: Dict):
    """ÏãúÏû• Ï≤¥Ïò®Í≥Ñ ÏûÑÍ≥ÑÍ∞í ÏóÖÎç∞Ïù¥Ìä∏ (Ìé∏Ïùò Ìï®Ïàò)"""
    market_thermometer.update_thresholds(new_thresholds)

def get_market_thermometer_thresholds() -> Dict:
    """ÏãúÏû• Ï≤¥Ïò®Í≥Ñ ÏûÑÍ≥ÑÍ∞í Ï°∞Ìöå (Ìé∏Ïùò Ìï®Ïàò)"""
    return market_thermometer.get_thresholds() 