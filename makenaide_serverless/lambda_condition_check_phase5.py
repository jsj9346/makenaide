#!/usr/bin/env python3
"""
üìä Phase 5: Condition Check Lambda
- Phase 4 4ÏãúÍ∞ÑÎ¥â Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Î∞õÏïÑ ÏµúÏ¢Ö Í±∞Îûò Ï°∞Í±¥ Í≤ÄÏ¶ù
- Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ Î∞è Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
- ÏµúÏ¢Ö BUY/SELL/HOLD Ïã†Ìò∏ ÏÉùÏÑ±
"""

import boto3
import json
import logging
import time
import pytz
import urllib3
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

# Î°úÍπÖ ÏÑ§Ï†ï
logger = logging.getLogger()
logger.setLevel(logging.INFO)

class ConditionChecker:
    """ÏµúÏ¢Ö Í±∞Îûò Ï°∞Í±¥ Í≤ÄÏ¶ù ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        self.s3_client = boto3.client('s3')
        self.events_client = boto3.client('events')
        self.s3_bucket = 'makenaide-bucket-901361833359'
        self.kst = pytz.timezone('Asia/Seoul')
        
        # Í±∞Îûò Ï°∞Í±¥ ÏÑ§Ï†ï
        self.config = {
            'max_positions': 3,           # ÏµúÎåÄ ÎèôÏãú Î≥¥Ïú† Ï¢ÖÎ™©
            'position_size_pct': 0.3,     # Ï¢ÖÎ™©Îãπ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÎπÑÏ§ë (30%)
            'min_volume_krw': 1000000000, # ÏµúÏÜå Í±∞ÎûòÎåÄÍ∏à (10ÏñµÏõê)
            'price_range': {              # Í∞ÄÍ≤©ÎåÄÎ≥Ñ ÌïÑÌÑ∞
                'min': 1000,              # ÏµúÏÜå 1,000Ïõê
                'max': 100000             # ÏµúÎåÄ 100,000Ïõê
            },
            'risk_management': {
                'stop_loss_pct': 0.08,    # ÏÜêÏ†à ÎπÑÏú® 8%
                'take_profit_pct': 0.25,  # 1Ï∞® ÏùµÏ†à ÎπÑÏú® 25%
                'max_daily_loss': 0.02,   # ÏùºÏùº ÏµúÎåÄ ÏÜêÏã§ 2%
                'rsi_overbought': 80,     # RSI Í≥ºÎß§Ïàò Íµ¨Í∞Ñ
                'correlation_limit': 0.7   # Ï¢ÖÎ™©Í∞Ñ ÏÉÅÍ¥ÄÍ≥ÑÏàò Ï†úÌïú
            },
            'market_condition': {
                'btc_correlation_max': 0.8, # BTC ÏÉÅÍ¥ÄÍ≥ÑÏàò ÏµúÎåÄÍ∞í
                'market_fear_min': 20,      # Í≥µÌè¨ÌÉêÏöïÏßÄÏàò ÏµúÏÜåÍ∞í
                'volatility_max': 0.15      # ÏµúÎåÄ Î≥ÄÎèôÏÑ± (15%)
            }
        }

    def load_phase4_data(self) -> Optional[List[Dict]]:
        """Phase 4 4ÏãúÍ∞ÑÎ¥â Î∂ÑÏÑù Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            logger.info("Phase 4 4ÏãúÍ∞ÑÎ¥â Î∂ÑÏÑù Í≤∞Í≥º Î°úÎìú Ï§ë...")
            
            response = self.s3_client.get_object(
                Bucket=self.s3_bucket,
                Key='phase4/4h_analysis_results.json'
            )
            
            data = json.loads(response['Body'].read())
            
            if data.get('status') != 'success':
                logger.error(f"Phase 4 Îç∞Ïù¥ÌÑ∞ ÏÉÅÌÉú Î∂àÎüâ: {data.get('status')}")
                return None
            
            analysis_results = data.get('analysis_results', [])
            if not analysis_results:
                logger.warning("Phase 4 Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÏóÜÏùå")
                return None
            
            # ÌÜµÍ≥ºÌïú Ï¢ÖÎ™©Îßå ÌïÑÌÑ∞ÎßÅ
            passed_results = [r for r in analysis_results if r.get('passed', False)]
            
            logger.info(f"Phase 4 Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {len(passed_results)}Í∞ú Ï¢ÖÎ™© ÌÜµÍ≥º")
            return passed_results
            
        except Exception as e:
            logger.error(f"Phase 4 Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            return None

    def fetch_current_market_data(self, ticker: str) -> Optional[Dict]:
        """ÌòÑÏû¨ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (Ïã§ÏãúÍ∞Ñ Í∞ÄÍ≤©, Í±∞ÎûòÎüâ)"""
        try:
            http = urllib3.PoolManager()
            
            # ÏóÖÎπÑÌä∏ ÌòÑÏû¨Í∞Ä Ï°∞Ìöå
            ticker_url = "https://api.upbit.com/v1/ticker"
            params = {'markets': ticker}
            param_string = '&'.join([f"{k}={v}" for k, v in params.items()])
            full_url = f"{ticker_url}?{param_string}"
            
            response = http.request('GET', full_url)
            
            if response.status != 200:
                logger.warning(f"{ticker} ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå®: {response.status}")
                return None
            
            ticker_data = json.loads(response.data.decode('utf-8'))
            
            if not ticker_data:
                return None
            
            current_data = ticker_data[0]
            
            # 24ÏãúÍ∞Ñ Í±∞ÎûòÎüâ Ï°∞Ìöå
            volume_url = "https://api.upbit.com/v1/candles/days"
            volume_params = {'market': ticker, 'count': 1}
            volume_param_string = '&'.join([f"{k}={v}" for k, v in volume_params.items()])
            volume_full_url = f"{volume_url}?{volume_param_string}"
            
            volume_response = http.request('GET', volume_full_url)
            
            if volume_response.status == 200:
                volume_data = json.loads(volume_response.data.decode('utf-8'))
                daily_volume_krw = volume_data[0]['candle_acc_trade_price'] if volume_data else 0
            else:
                daily_volume_krw = 0
            
            market_data = {
                'ticker': ticker,
                'current_price': float(current_data['trade_price']),
                'change_rate': float(current_data.get('signed_change_rate', 0)) * 100,
                'volume_24h': float(current_data.get('acc_trade_volume_24h', 0)),
                'volume_24h_krw': daily_volume_krw,
                'high_price': float(current_data.get('high_price', 0)),
                'low_price': float(current_data.get('low_price', 0)),
                'timestamp': datetime.now(self.kst).isoformat()
            }
            
            logger.info(f"{ticker} ÌòÑÏû¨ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏôÑÎ£å")
            return market_data
            
        except Exception as e:
            logger.error(f"{ticker} ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
            return None

    def check_basic_conditions(self, market_data: Dict, phase4_data: Dict) -> Dict:
        """Í∏∞Î≥∏ Í±∞Îûò Ï°∞Í±¥ Í≤ÄÏ¶ù"""
        try:
            ticker = market_data['ticker']
            current_price = market_data['current_price']
            volume_24h_krw = market_data['volume_24h_krw']
            
            conditions = {
                'price_range': False,
                'volume_requirement': False,
                'volatility_check': False,
                'reasons': []
            }
            
            # 1. Í∞ÄÍ≤©ÎåÄ Í≤ÄÏ¶ù
            if (self.config['price_range']['min'] <= current_price <= 
                self.config['price_range']['max']):
                conditions['price_range'] = True
                conditions['reasons'].append(f"Í∞ÄÍ≤©ÎåÄ Ï†ÅÏ†ï ({current_price:,.0f}Ïõê)")
            else:
                conditions['reasons'].append(f"Í∞ÄÍ≤©ÎåÄ Î∂ÄÏ†ÅÏ†ï ({current_price:,.0f}Ïõê)")
            
            # 2. Í±∞ÎûòÎüâ Í≤ÄÏ¶ù
            if volume_24h_krw >= self.config['min_volume_krw']:
                conditions['volume_requirement'] = True
                conditions['reasons'].append(f"Í±∞ÎûòÎüâ Ï∂©Ï°± ({volume_24h_krw/1e8:.1f}ÏñµÏõê)")
            else:
                conditions['reasons'].append(f"Í±∞ÎûòÎüâ Î∂ÄÏ°± ({volume_24h_krw/1e8:.1f}ÏñµÏõê)")
            
            # 3. Î≥ÄÎèôÏÑ± Í≤ÄÏ¶ù (Í≥†Í∞Ä-Ï†ÄÍ∞Ä ÎπÑÏú®)
            high_price = market_data['high_price']
            low_price = market_data['low_price']
            
            if high_price > 0 and low_price > 0:
                daily_volatility = (high_price - low_price) / low_price
                if daily_volatility <= self.config['market_condition']['volatility_max']:
                    conditions['volatility_check'] = True
                    conditions['reasons'].append(f"Î≥ÄÎèôÏÑ± Ï†ÅÏ†ï ({daily_volatility:.1%})")
                else:
                    conditions['reasons'].append(f"Î≥ÄÎèôÏÑ± Í≥ºÎèÑ ({daily_volatility:.1%})")
            else:
                conditions['volatility_check'] = True  # Îç∞Ïù¥ÌÑ∞ ÏóÜÏúºÎ©¥ ÌÜµÍ≥º
                conditions['reasons'].append("Î≥ÄÎèôÏÑ± Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
            
            # Ï†ÑÏ≤¥ Ï°∞Í±¥ ÌÜµÍ≥º Ïó¨Î∂Ä
            conditions['passed'] = all([
                conditions['price_range'],
                conditions['volume_requirement'],
                conditions['volatility_check']
            ])
            
            logger.info(f"{'‚úÖ' if conditions['passed'] else '‚ùå'} {ticker} Í∏∞Î≥∏ Ï°∞Í±¥ Í≤ÄÏ¶ù")
            
            return conditions
            
        except Exception as e:
            logger.error(f"Í∏∞Î≥∏ Ï°∞Í±¥ Í≤ÄÏ¶ù Ïã§Ìå®: {e}")
            return {'passed': False, 'reasons': ['Í≤ÄÏ¶ù Ïò§Î•ò']}

    def calculate_risk_metrics(self, market_data: Dict, phase4_data: Dict) -> Dict:
        """Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            ticker = market_data['ticker']
            current_price = market_data['current_price']
            
            # Phase 4ÏóêÏÑú Í∞ÄÏ†∏Ïò® Í∏∞Ïà†Ï†Å ÏßÄÌëú
            indicators = phase4_data.get('indicators', {})
            rsi = indicators.get('rsi', 50)
            ma200 = indicators.get('ma200', current_price)
            
            # Î¶¨Ïä§ÌÅ¨ Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞
            risk_metrics = {
                'stop_loss_price': current_price * (1 - self.config['risk_management']['stop_loss_pct']),
                'take_profit_price': current_price * (1 + self.config['risk_management']['take_profit_pct']),
                'ma200_distance': ((current_price - ma200) / ma200) if ma200 > 0 else 0,
                'rsi_risk_level': 'HIGH' if rsi >= self.config['risk_management']['rsi_overbought'] else 'NORMAL',
                'position_risk_score': 0,  # Í∏∞Î≥∏Í∞í
                'risk_reward_ratio': self.config['risk_management']['take_profit_pct'] / self.config['risk_management']['stop_loss_pct']
            }
            
            # ÏúÑÏπò Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í≥ÑÏÇ∞ (0-100)
            risk_score = 0
            
            # RSI Í≥ºÎß§Ïàò Î¶¨Ïä§ÌÅ¨
            if rsi >= 80:
                risk_score += 30
            elif rsi >= 70:
                risk_score += 15
            
            # MA200 Í±∞Î¶¨ Î¶¨Ïä§ÌÅ¨
            ma_distance = abs(risk_metrics['ma200_distance'])
            if ma_distance > 0.3:  # 30% Ïù¥ÏÉÅ Í¥¥Î¶¨
                risk_score += 25
            elif ma_distance > 0.2:  # 20% Ïù¥ÏÉÅ Í¥¥Î¶¨
                risk_score += 15
            
            # 24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•† Î¶¨Ïä§ÌÅ¨
            change_rate = abs(market_data.get('change_rate', 0))
            if change_rate > 10:  # 10% Ïù¥ÏÉÅ Î≥ÄÎèô
                risk_score += 20
            elif change_rate > 5:  # 5% Ïù¥ÏÉÅ Î≥ÄÎèô
                risk_score += 10
            
            risk_metrics['position_risk_score'] = min(100, risk_score)
            
            logger.info(f"{ticker} Î¶¨Ïä§ÌÅ¨ Ï†êÏàò: {risk_score}/100")
            
            return risk_metrics
            
        except Exception as e:
            logger.error(f"Î¶¨Ïä§ÌÅ¨ Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return {}

    def calculate_position_size(self, market_data: Dict, risk_metrics: Dict) -> Dict:
        """Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞"""
        try:
            ticker = market_data['ticker']
            current_price = market_data['current_price']
            risk_score = risk_metrics.get('position_risk_score', 50)
            
            # Í∏∞Î≥∏ Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ (Ìè¨Ìä∏Ìè¥Î¶¨Ïò§Ïùò 30%)
            base_position_pct = self.config['position_size_pct']
            
            # Î¶¨Ïä§ÌÅ¨ Ï†êÏàòÏóê Îî∞Î•∏ Ìè¨ÏßÄÏÖò Ï°∞Ï†ï
            if risk_score >= 70:
                adjusted_position_pct = base_position_pct * 0.5  # 50% Í∞êÏÜå
            elif risk_score >= 50:
                adjusted_position_pct = base_position_pct * 0.7  # 30% Í∞êÏÜå
            elif risk_score >= 30:
                adjusted_position_pct = base_position_pct * 0.85 # 15% Í∞êÏÜå
            else:
                adjusted_position_pct = base_position_pct  # ÏõêÎûò ÌÅ¨Í∏∞
            
            # ÏµúÏÜå/ÏµúÎåÄ Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Ï†úÌïú
            adjusted_position_pct = max(0.1, min(0.4, adjusted_position_pct))
            
            position_info = {
                'ticker': ticker,
                'base_position_pct': base_position_pct,
                'adjusted_position_pct': adjusted_position_pct,
                'risk_adjustment_factor': adjusted_position_pct / base_position_pct,
                'entry_price': current_price,
                'stop_loss_price': risk_metrics.get('stop_loss_price', 0),
                'take_profit_price': risk_metrics.get('take_profit_price', 0),
                'max_loss_pct': self.config['risk_management']['stop_loss_pct'],
                'expected_profit_pct': self.config['risk_management']['take_profit_pct']
            }
            
            logger.info(f"{ticker} Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞: {adjusted_position_pct:.1%} (ÏúÑÌóòÎèÑ Ï°∞Ï†ï: {adjusted_position_pct/base_position_pct:.1%})")
            
            return position_info
            
        except Exception as e:
            logger.error(f"Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return {}

    def generate_final_signal(self, market_data: Dict, phase4_data: Dict, 
                            basic_conditions: Dict, risk_metrics: Dict, 
                            position_info: Dict) -> Dict:
        """ÏµúÏ¢Ö Í±∞Îûò Ïã†Ìò∏ ÏÉùÏÑ±"""
        try:
            ticker = market_data['ticker']
            
            # Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞
            technical_score = phase4_data.get('score', 0)  # Phase 4 Í∏∞Ïà†Ï†Å Ï†êÏàò (0-7)
            gpt_score = phase4_data.get('gpt_score', 0)    # GPT Ï†êÏàò (0-10)
            gpt_confidence = phase4_data.get('gpt_confidence', 0)  # GPT Ïã†Î¢∞ÎèÑ (0-10)
            
            # Ï†ïÍ∑úÌôîÎêú Ï¢ÖÌï© Ï†êÏàò (0-100)
            composite_score = (
                (technical_score / 7.0) * 40 +     # Í∏∞Ïà†Ï†Å Î∂ÑÏÑù 40%
                (gpt_score / 10.0) * 35 +          # GPT Ï†êÏàò 35%
                (gpt_confidence / 10.0) * 25       # GPT Ïã†Î¢∞ÎèÑ 25%
            ) * 100
            
            # Î¶¨Ïä§ÌÅ¨ Ï°∞Ï†ï Ï†êÏàò
            risk_score = risk_metrics.get('position_risk_score', 50)
            risk_adjusted_score = composite_score * (1 - risk_score / 200)  # Î¶¨Ïä§ÌÅ¨Ïóê Îî∞Îùº Í∞êÏ†ê
            
            # ÏµúÏ¢Ö Ïã†Ìò∏ Í≤∞Ï†ï
            signal = 'HOLD'
            confidence = 0
            reasons = []
            
            # BUY Ïã†Ìò∏ Ï°∞Í±¥
            if (basic_conditions.get('passed', False) and 
                risk_adjusted_score >= 70 and 
                risk_score <= 60):
                signal = 'BUY'
                confidence = min(95, risk_adjusted_score)
                reasons.append(f"Ï¢ÖÌï©Ï†êÏàò Ïö∞Ïàò ({risk_adjusted_score:.1f})")
                reasons.append(f"Î¶¨Ïä§ÌÅ¨ ÏàòÏö© Í∞ÄÎä• ({risk_score})")
            
            # STRONG_BUY Ïã†Ìò∏ Ï°∞Í±¥ (Îçî ÏóÑÍ≤©)
            elif (basic_conditions.get('passed', False) and 
                  risk_adjusted_score >= 85 and 
                  risk_score <= 40 and
                  technical_score >= 6 and
                  gpt_confidence >= 8):
                signal = 'STRONG_BUY'
                confidence = min(99, risk_adjusted_score)
                reasons.append(f"ÏµúÍ≥† Îì±Í∏â Ïã†Ìò∏ ({risk_adjusted_score:.1f})")
                reasons.append(f"Ï†ÄÏúÑÌóò Í≥†Ïã†Î¢∞ÎèÑ ({risk_score}, {gpt_confidence})")
            
            # HOLD/REJECT Ïã†Ìò∏
            else:
                if not basic_conditions.get('passed', False):
                    signal = 'REJECT'
                    reasons.append("Í∏∞Î≥∏ Ï°∞Í±¥ ÎØ∏Ï∂©Ï°±")
                elif risk_score > 70:
                    signal = 'REJECT'
                    reasons.append(f"Í≥†ÏúÑÌóò ({risk_score})")
                elif risk_adjusted_score < 50:
                    signal = 'REJECT'
                    reasons.append(f"ÎÇÆÏùÄ Ï¢ÖÌï©Ï†êÏàò ({risk_adjusted_score:.1f})")
                else:
                    signal = 'HOLD'
                    reasons.append("Í¥ÄÎßù Í∂åÏû•")
                
                confidence = max(10, 100 - risk_adjusted_score)
            
            # ÏµúÏ¢Ö Ïã†Ìò∏ Íµ¨ÏÑ±
            final_signal = {
                'ticker': ticker,
                'signal': signal,
                'confidence': confidence,
                'composite_score': composite_score,
                'risk_adjusted_score': risk_adjusted_score,
                'technical_score': technical_score,
                'gpt_score': gpt_score,
                'gpt_confidence': gpt_confidence,
                'risk_score': risk_score,
                'reasons': reasons,
                'market_data': market_data,
                'position_info': position_info,
                'risk_metrics': risk_metrics,
                'basic_conditions': basic_conditions,
                'analysis_timestamp': datetime.now(self.kst).isoformat(),
                'phase4_data': phase4_data
            }
            
            signal_emoji = {
                'STRONG_BUY': 'üöÄ',
                'BUY': '‚úÖ',
                'HOLD': '‚è≥',
                'REJECT': '‚ùå'
            }
            
            logger.info(f"{signal_emoji.get(signal, '‚ùì')} {ticker} ÏµúÏ¢Ö Ïã†Ìò∏: {signal} (Ïã†Î¢∞ÎèÑ: {confidence:.0f}%)")
            
            return final_signal
            
        except Exception as e:
            logger.error(f"ÏµúÏ¢Ö Ïã†Ìò∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return None

    def process_ticker(self, phase4_data: Dict) -> Optional[Dict]:
        """Í∞úÎ≥Ñ Ï¢ÖÎ™© ÏµúÏ¢Ö Ï°∞Í±¥ Í≤ÄÏ¶ù"""
        try:
            ticker = phase4_data.get('ticker', '')
            logger.info(f"ÏµúÏ¢Ö Ï°∞Í±¥ Í≤ÄÏ¶ù ÏãúÏûë: {ticker}")
            
            # 1. ÌòÑÏû¨ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            market_data = self.fetch_current_market_data(ticker)
            if not market_data:
                return None
            
            # API Ìò∏Ï∂ú Í∞ÑÍ≤© Ï°∞Ï†à
            time.sleep(0.3)
            
            # 2. Í∏∞Î≥∏ Ï°∞Í±¥ Í≤ÄÏ¶ù
            basic_conditions = self.check_basic_conditions(market_data, phase4_data)
            
            # 3. Î¶¨Ïä§ÌÅ¨ Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞
            risk_metrics = self.calculate_risk_metrics(market_data, phase4_data)
            
            # 4. Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            position_info = self.calculate_position_size(market_data, risk_metrics)
            
            # 5. ÏµúÏ¢Ö Ïã†Ìò∏ ÏÉùÏÑ±
            final_signal = self.generate_final_signal(
                market_data, phase4_data, basic_conditions, 
                risk_metrics, position_info
            )
            
            return final_signal
            
        except Exception as e:
            logger.error(f"Ï¢ÖÎ™© Ï≤òÎ¶¨ Ïã§Ìå®: {e}")
            return None

    def process_all_tickers(self, phase4_results: List[Dict]) -> List[Dict]:
        """Î™®Îì† Ï¢ÖÎ™© ÏµúÏ¢Ö Ï°∞Í±¥ Í≤ÄÏ¶ù"""
        final_signals = []
        
        logger.info(f"ÏµúÏ¢Ö Ï°∞Í±¥ Í≤ÄÏ¶ù ÏãúÏûë: {len(phase4_results)}Í∞ú Ï¢ÖÎ™©")
        
        for i, phase4_data in enumerate(phase4_results):
            try:
                # API Ìò∏Ï∂ú Í∞ÑÍ≤© Ï°∞Ï†à
                if i > 0:
                    time.sleep(0.5)
                
                signal = self.process_ticker(phase4_data)
                if signal:
                    final_signals.append(signal)
                
                logger.info(f"ÏßÑÌñâ ÏÉÅÌô©: {i+1}/{len(phase4_results)}")
                
            except Exception as e:
                logger.error(f"Ï¢ÖÎ™© Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
                continue
        
        # Ïã†Ìò∏Î≥Ñ Ï†ïÎ†¨ (STRONG_BUY > BUY > HOLD > REJECT)
        signal_priority = {'STRONG_BUY': 4, 'BUY': 3, 'HOLD': 2, 'REJECT': 1}
        final_signals.sort(
            key=lambda x: (
                signal_priority.get(x.get('signal', 'REJECT'), 0),
                x.get('confidence', 0)
            ),
            reverse=True
        )
        
        # ÌÜµÍ≥Ñ Ï†ïÎ≥¥
        signal_counts = {}
        for signal in final_signals:
            sig = signal.get('signal', 'UNKNOWN')
            signal_counts[sig] = signal_counts.get(sig, 0) + 1
        
        logger.info(f"ÏµúÏ¢Ö Ï°∞Í±¥ Í≤ÄÏ¶ù ÏôÑÎ£å: {signal_counts}")
        return final_signals

    def save_results_to_s3(self, final_signals: List[Dict]) -> bool:
        """Í≤∞Í≥ºÎ•º S3Ïóê Ï†ÄÏû•"""
        try:
            timestamp = datetime.now(self.kst).strftime('%Y%m%d_%H%M%S')
            
            # BUY Ïù¥ÏÉÅ Ïã†Ìò∏Îßå Ï∂îÏ∂ú
            buy_signals = [s for s in final_signals if s.get('signal') in ['BUY', 'STRONG_BUY']]
            
            # Ïã†Ìò∏Î≥Ñ ÌÜµÍ≥Ñ
            signal_stats = {}
            for signal in final_signals:
                sig = signal.get('signal', 'UNKNOWN')
                signal_stats[sig] = signal_stats.get(sig, 0) + 1
            
            output_data = {
                'phase': 'condition_check',
                'status': 'success',
                'timestamp': datetime.now(self.kst).isoformat(),
                'processed_count': len(final_signals),
                'buy_signal_count': len(buy_signals),
                'final_signals': final_signals,
                'buy_candidates': [s['ticker'] for s in buy_signals],
                'signal_statistics': signal_stats,
                'config': self.config,
                'summary': {
                    'total_processed': len(final_signals),
                    'strong_buy': signal_stats.get('STRONG_BUY', 0),
                    'buy': signal_stats.get('BUY', 0),
                    'hold': signal_stats.get('HOLD', 0),
                    'reject': signal_stats.get('REJECT', 0),
                    'avg_confidence': sum(s.get('confidence', 0) for s in buy_signals) / len(buy_signals) if buy_signals else 0,
                    'top_pick': buy_signals[0]['ticker'] if buy_signals else None
                }
            }
            
            # Î©îÏù∏ Í≤∞Í≥º ÌååÏùº
            main_key = 'phase5/condition_check_results.json'
            self.s3_client.put_object(
                Bucket=self.s3_bucket,
                Key=main_key,
                Body=json.dumps(output_data, ensure_ascii=False),
                ContentType='application/json'
            )
            
            # Î∞±ÏóÖ ÌååÏùº
            backup_key = f'phase5/backups/condition_check_{timestamp}.json'
            self.s3_client.put_object(
                Bucket=self.s3_bucket,
                Key=backup_key,
                Body=json.dumps(output_data, ensure_ascii=False),
                ContentType='application/json'
            )
            
            logger.info(f"Í≤∞Í≥º S3 Ï†ÄÏû• ÏôÑÎ£å: {main_key}")
            return True
            
        except Exception as e:
            logger.error(f"S3 Ï†ÄÏû• Ïã§Ìå®: {e}")
            return False

    def trigger_execution_phase(self):
        """Í±∞Îûò Ïã§Ìñâ Îã®Í≥Ñ Ìä∏Î¶¨Í±∞ Ïù¥Î≤§Ìä∏ Î∞úÏÜ°"""
        try:
            event_detail = {
                'phase': 'condition_check',
                'status': 'completed',
                'timestamp': datetime.now(self.kst).isoformat(),
                'next_phase': 'execution'
            }
            
            self.events_client.put_events(
                Entries=[
                    {
                        'Source': 'makenaide.condition_check',
                        'DetailType': 'Condition Check Completed',
                        'Detail': json.dumps(event_detail)
                    }
                ]
            )
            
            logger.info("Í±∞Îûò Ïã§Ìñâ Îã®Í≥Ñ Ìä∏Î¶¨Í±∞ Ïù¥Î≤§Ìä∏ Î∞úÏÜ° ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"Í±∞Îûò Ïã§Ìñâ Ìä∏Î¶¨Í±∞ Ïã§Ìå®: {e}")

def lambda_handler(event, context):
    """Lambda Ìï∏Îì§Îü¨"""
    start_time = datetime.now()
    
    try:
        logger.info("=== Phase 5: Condition Check ÏãúÏûë ===")
        logger.info(f"Ïù¥Î≤§Ìä∏: {json.dumps(event)}")
        
        # Ï°∞Í±¥ Í≤ÄÏ¶ùÍ∏∞ Ï¥àÍ∏∞Ìôî
        checker = ConditionChecker()
        
        # Phase 4 Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        phase4_data = checker.load_phase4_data()
        if not phase4_data:
            return {
                'statusCode': 400,
                'phase': 'condition_check',
                'error': 'Phase 4 Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå',
                'message': 'Phase 4Î•º Î®ºÏ†Ä Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî'
            }
        
        # ÏµúÏ¢Ö Ï°∞Í±¥ Í≤ÄÏ¶ù Ïã§Ìñâ
        final_signals = checker.process_all_tickers(phase4_data)
        
        # Í≤∞Í≥º Ï†ÄÏû•
        s3_saved = checker.save_results_to_s3(final_signals)
        
        # BUY Ïã†Ìò∏Í∞Ä ÏûàÏúºÎ©¥ Í±∞Îûò Ïã§Ìñâ Îã®Í≥Ñ Ìä∏Î¶¨Í±∞
        buy_signals = [s for s in final_signals if s.get('signal') in ['BUY', 'STRONG_BUY']]
        if buy_signals and s3_saved:
            checker.trigger_execution_phase()
        
        # Ïã§Ìñâ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
        execution_time = (datetime.now() - start_time).total_seconds()
        
        # Ïã†Ìò∏ ÌÜµÍ≥Ñ
        signal_stats = {}
        for signal in final_signals:
            sig = signal.get('signal', 'UNKNOWN')
            signal_stats[sig] = signal_stats.get(sig, 0) + 1
        
        # ÏÑ±Í≥µ ÏùëÎãµ
        response = {
            'statusCode': 200,
            'phase': 'condition_check',
            'input_tickers': len(phase4_data),
            'processed_tickers': len(final_signals),
            'buy_signals': len(buy_signals),
            'signal_statistics': signal_stats,
            'buy_candidates': [s['ticker'] for s in buy_signals],
            'top_pick': buy_signals[0]['ticker'] if buy_signals else None,
            'execution_time': f"{execution_time:.2f}Ï¥à",
            's3_saved': s3_saved,
            'timestamp': datetime.now().isoformat()
        }
        
        logger.info(f"=== Phase 5 ÏôÑÎ£å ===")
        logger.info(f"Í≤∞Í≥º: {response}")
        
        return response
        
    except Exception as e:
        logger.error(f"Phase 5 Ïã§Ìñâ Ïã§Ìå®: {e}")
        return {
            'statusCode': 500,
            'phase': 'condition_check',
            'error': str(e),
            'message': 'Phase 5 Ïã§Ìñâ Ï§ë Ïò§Î•ò Î∞úÏÉù'
        }