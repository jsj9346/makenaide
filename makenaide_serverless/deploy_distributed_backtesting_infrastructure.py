#!/usr/bin/env python3
"""
Î∂ÑÏÇ∞ Î∞±ÌÖåÏä§ÌåÖ Ïù∏ÌîÑÎùº Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏

Phase 1: ÌïµÏã¨ Ïù∏ÌîÑÎùº Íµ¨Ï∂ï
- SQS ÌÅê ÏãúÏä§ÌÖú (ÏûëÏóÖ ÌÅê, Í≤∞Í≥º ÌÅê, DLQ)
- DynamoDB ÌÖåÏù¥Î∏î (ÏûëÏóÖ Ï∂îÏ†Å, Í≤∞Í≥º Ï†ÄÏû•) 
- Í∏∞Î≥∏ Lambda Ìï®Ïàò ÌîÑÎ†àÏûÑÏõåÌÅ¨

Author: Distributed Backtesting Infrastructure
Version: 1.0.0
"""

import boto3
import json
import logging
from datetime import datetime
from typing import Dict, List, Any

# Î°úÍ±∞ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DistributedBacktestingInfrastructure:
    """Î∂ÑÏÇ∞ Î∞±ÌÖåÏä§ÌåÖ Ïù∏ÌîÑÎùº Î∞∞Ìè¨ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, region_name: str = 'ap-northeast-2'):
        self.region = region_name
        self.sqs_client = boto3.client('sqs', region_name=region_name)
        self.dynamodb = boto3.resource('dynamodb', region_name=region_name)
        self.lambda_client = boto3.client('lambda', region_name=region_name)
        self.iam_client = boto3.client('iam', region_name=region_name)
        
        # Î¶¨ÏÜåÏä§ Ïù¥Î¶Ñ Ï†ëÎëêÏÇ¨
        self.resource_prefix = "makenaide-distributed-backtest"
        
        logger.info(f"üöÄ Î∂ÑÏÇ∞ Î∞±ÌÖåÏä§ÌåÖ Ïù∏ÌîÑÎùº Î∞∞Ìè¨ Ï§ÄÎπÑ ÏôÑÎ£å (Î¶¨Ï†Ñ: {region_name})")
    
    def deploy_sqs_queues(self) -> Dict[str, str]:
        """SQS ÌÅê ÏãúÏä§ÌÖú Î∞∞Ìè¨"""
        try:
            logger.info("üì° SQS ÌÅê ÏãúÏä§ÌÖú Î∞∞Ìè¨ ÏãúÏûë")
            
            queue_configs = {
                # 1. Î∞±ÌÖåÏä§Ìä∏ ÏûëÏóÖ ÌÅê (Î©îÏù∏)
                f"{self.resource_prefix}-job-queue": {
                    "Attributes": {
                        'VisibilityTimeout': '900',  # 15Î∂Ñ
                        'MessageRetentionPeriod': '1209600',  # 14Ïùº
                        'ReceiveMessageWaitTimeSeconds': '20',  # Long polling
                        'RedrivePolicy': json.dumps({
                            'deadLetterTargetArn': f"arn:aws:sqs:{self.region}:{{AccountId}}:{self.resource_prefix}-dlq",
                            'maxReceiveCount': 3
                        })
                    }
                },
                
                # 2. Ïö∞ÏÑ†ÏàúÏúÑ ÏûëÏóÖ ÌÅê (FIFO)
                f"{self.resource_prefix}-priority-queue.fifo": {
                    "Attributes": {
                        'FifoQueue': 'true',
                        'ContentBasedDeduplication': 'true',
                        'VisibilityTimeout': '600',
                        'MessageRetentionPeriod': '1209600'
                    }
                },
                
                # 3. Í≤∞Í≥º ÏàòÏßë ÌÅê
                f"{self.resource_prefix}-result-queue": {
                    "Attributes": {
                        'VisibilityTimeout': '300',  # 5Î∂Ñ
                        'MessageRetentionPeriod': '604800',  # 7Ïùº
                        'ReceiveMessageWaitTimeSeconds': '20'
                    }
                },
                
                # 4. Dead Letter Queue
                f"{self.resource_prefix}-dlq": {
                    "Attributes": {
                        'MessageRetentionPeriod': '1209600'  # 14Ïùº
                    }
                }
            }
            
            created_queues = {}
            
            for queue_name, config in queue_configs.items():
                try:
                    # DLQÎäî Îã§Î•∏ ÌÅêÎì§Î≥¥Îã§ Î®ºÏ†Ä ÏÉùÏÑ±ÎêòÏñ¥Ïïº Ìï®
                    if 'dlq' in queue_name:
                        response = self.sqs_client.create_queue(
                            QueueName=queue_name,
                            Attributes=config['Attributes']
                        )
                        created_queues[queue_name] = response['QueueUrl']
                        logger.info(f"‚úÖ DLQ ÏÉùÏÑ± ÏôÑÎ£å: {queue_name}")
                
                except self.sqs_client.exceptions.QueueNameExists:
                    # Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÌÅêÏùò URL Í∞ÄÏ†∏Ïò§Í∏∞
                    response = self.sqs_client.get_queue_url(QueueName=queue_name)
                    created_queues[queue_name] = response['QueueUrl']
                    logger.info(f"üîÑ Í∏∞Ï°¥ DLQ ÏÇ¨Ïö©: {queue_name}")
            
            # ÎÇòÎ®∏ÏßÄ ÌÅê ÏÉùÏÑ± (DLQ ARNÏùÑ ÏïåÍ≥† ÎÇòÏÑú)
            account_id = boto3.client('sts').get_caller_identity()['Account']
            
            for queue_name, config in queue_configs.items():
                if 'dlq' in queue_name:
                    continue  # Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®
                
                try:
                    # RedrivePolicyÏùò AccountId ÏπòÌôò
                    if 'RedrivePolicy' in config['Attributes']:
                        redrive_policy = config['Attributes']['RedrivePolicy']
                        config['Attributes']['RedrivePolicy'] = redrive_policy.replace(
                            '{AccountId}', account_id
                        )
                    
                    response = self.sqs_client.create_queue(
                        QueueName=queue_name,
                        Attributes=config['Attributes']
                    )
                    created_queues[queue_name] = response['QueueUrl']
                    logger.info(f"‚úÖ ÌÅê ÏÉùÏÑ± ÏôÑÎ£å: {queue_name}")
                    
                except self.sqs_client.exceptions.QueueNameExists:
                    response = self.sqs_client.get_queue_url(QueueName=queue_name)
                    created_queues[queue_name] = response['QueueUrl']
                    logger.info(f"üîÑ Í∏∞Ï°¥ ÌÅê ÏÇ¨Ïö©: {queue_name}")
                
                except Exception as e:
                    logger.error(f"‚ùå ÌÅê ÏÉùÏÑ± Ïã§Ìå® ({queue_name}): {e}")
            
            logger.info(f"üéâ SQS ÌÅê ÏãúÏä§ÌÖú Î∞∞Ìè¨ ÏôÑÎ£å: {len(created_queues)}Í∞ú ÌÅê")
            return created_queues
            
        except Exception as e:
            logger.error(f"‚ùå SQS ÌÅê ÏãúÏä§ÌÖú Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            return {}
    
    def deploy_dynamodb_tables(self) -> Dict[str, str]:
        """DynamoDB ÌÖåÏù¥Î∏î Î∞∞Ìè¨"""
        try:
            logger.info("üóÑÔ∏è DynamoDB ÌÖåÏù¥Î∏î Î∞∞Ìè¨ ÏãúÏûë")
            
            table_configs = {
                # 1. Î∞±ÌÖåÏä§Ìä∏ ÏûëÏóÖ Ï∂îÏ†Å ÌÖåÏù¥Î∏î
                f"{self.resource_prefix}-jobs": {
                    "KeySchema": [
                        {
                            'AttributeName': 'job_id',
                            'KeyType': 'HASH'
                        }
                    ],
                    "AttributeDefinitions": [
                        {
                            'AttributeName': 'job_id',
                            'AttributeType': 'S'
                        },
                        {
                            'AttributeName': 'status',
                            'AttributeType': 'S'
                        },
                        {
                            'AttributeName': 'created_at',
                            'AttributeType': 'S'
                        }
                    ],
                    "GlobalSecondaryIndexes": [
                        {
                            'IndexName': 'status-created_at-index',
                            'KeySchema': [
                                {
                                    'AttributeName': 'status',
                                    'KeyType': 'HASH'
                                },
                                {
                                    'AttributeName': 'created_at', 
                                    'KeyType': 'RANGE'
                                }
                            ],
                            'Projection': {
                                'ProjectionType': 'ALL'
                            }
                        }
                    ]
                },
                
                # 2. Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï†ÄÏû• ÌÖåÏù¥Î∏î
                f"{self.resource_prefix}-results": {
                    "KeySchema": [
                        {
                            'AttributeName': 'job_id',
                            'KeyType': 'HASH'
                        }
                    ],
                    "AttributeDefinitions": [
                        {
                            'AttributeName': 'job_id',
                            'AttributeType': 'S'
                        },
                        {
                            'AttributeName': 'strategy_name',
                            'AttributeType': 'S'
                        },
                        {
                            'AttributeName': 'completed_at',
                            'AttributeType': 'S'
                        }
                    ],
                    "GlobalSecondaryIndexes": [
                        {
                            'IndexName': 'strategy-completed_at-index',
                            'KeySchema': [
                                {
                                    'AttributeName': 'strategy_name',
                                    'KeyType': 'HASH'
                                },
                                {
                                    'AttributeName': 'completed_at',
                                    'KeyType': 'RANGE'
                                }
                            ],
                            'Projection': {
                                'ProjectionType': 'ALL'
                            }
                        }
                    ]
                },
                
                # 3. Î∞±ÌÖåÏä§Ìä∏ ÏÑ∏ÏÖò Í¥ÄÎ¶¨ ÌÖåÏù¥Î∏î
                f"{self.resource_prefix}-sessions": {
                    "KeySchema": [
                        {
                            'AttributeName': 'session_id',
                            'KeyType': 'HASH'
                        }
                    ],
                    "AttributeDefinitions": [
                        {
                            'AttributeName': 'session_id',
                            'AttributeType': 'S'
                        },
                        {
                            'AttributeName': 'created_at',
                            'AttributeType': 'S'
                        }
                    ],
                    "GlobalSecondaryIndexes": [
                        {
                            'IndexName': 'created_at-index',
                            'KeySchema': [
                                {
                                    'AttributeName': 'created_at',
                                    'KeyType': 'HASH'
                                }
                            ],
                            'Projection': {
                                'ProjectionType': 'ALL'
                            }
                        }
                    ]
                }
            }
            
            created_tables = {}
            
            for table_name, config in table_configs.items():
                try:
                    table = self.dynamodb.create_table(
                        TableName=table_name,
                        BillingMode='PAY_PER_REQUEST',
                        **config
                    )
                    
                    # ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÎåÄÍ∏∞
                    table.wait_until_exists()
                    created_tables[table_name] = table.table_arn
                    logger.info(f"‚úÖ ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÏôÑÎ£å: {table_name}")
                    
                except Exception as e:
                    if "already exists" in str(e) or "ResourceInUseException" in str(e):
                        table = self.dynamodb.Table(table_name)
                        created_tables[table_name] = table.table_arn
                        logger.info(f"üîÑ Í∏∞Ï°¥ ÌÖåÏù¥Î∏î ÏÇ¨Ïö©: {table_name}")
                    else:
                        logger.error(f"‚ùå ÌÖåÏù¥Î∏î ÏÉùÏÑ± Ïã§Ìå® ({table_name}): {e}")
            
            logger.info(f"üéâ DynamoDB ÌÖåÏù¥Î∏î Î∞∞Ìè¨ ÏôÑÎ£å: {len(created_tables)}Í∞ú ÌÖåÏù¥Î∏î")
            return created_tables
            
        except Exception as e:
            logger.error(f"‚ùå DynamoDB ÌÖåÏù¥Î∏î Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            return {}
    
    def create_lambda_execution_role(self) -> str:
        """Lambda Ïã§Ìñâ Ïó≠Ìï† ÏÉùÏÑ±"""
        try:
            role_name = f"{self.resource_prefix}-lambda-role"
            
            # Ïã†Î¢∞ Ï†ïÏ±Ö
            trust_policy = {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Principal": {
                            "Service": "lambda.amazonaws.com"
                        },
                        "Action": "sts:AssumeRole"
                    }
                ]
            }
            
            # Í∂åÌïú Ï†ïÏ±Ö
            permission_policy = {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": [
                            "logs:CreateLogGroup",
                            "logs:CreateLogStream", 
                            "logs:PutLogEvents"
                        ],
                        "Resource": "*"
                    },
                    {
                        "Effect": "Allow",
                        "Action": [
                            "sqs:ReceiveMessage",
                            "sqs:DeleteMessage",
                            "sqs:SendMessage",
                            "sqs:GetQueueAttributes"
                        ],
                        "Resource": f"arn:aws:sqs:{self.region}:*:{self.resource_prefix}-*"
                    },
                    {
                        "Effect": "Allow",
                        "Action": [
                            "dynamodb:GetItem",
                            "dynamodb:PutItem",
                            "dynamodb:UpdateItem",
                            "dynamodb:Query",
                            "dynamodb:Scan"
                        ],
                        "Resource": f"arn:aws:dynamodb:{self.region}:*:table/{self.resource_prefix}-*"
                    },
                    {
                        "Effect": "Allow",
                        "Action": [
                            "s3:GetObject",
                            "s3:PutObject"
                        ],
                        "Resource": "arn:aws:s3:::makenaide-*/*"
                    }
                ]
            }
            
            try:
                # Ïó≠Ìï† ÏÉùÏÑ±
                response = self.iam_client.create_role(
                    RoleName=role_name,
                    AssumeRolePolicyDocument=json.dumps(trust_policy),
                    Description="Distributed Backtesting Lambda Execution Role"
                )
                role_arn = response['Role']['Arn']
                logger.info(f"‚úÖ Lambda Ïã§Ìñâ Ïó≠Ìï† ÏÉùÏÑ±: {role_name}")
                
                # Í∂åÌïú Ï†ïÏ±Ö Ï≤®Î∂Ä
                self.iam_client.put_role_policy(
                    RoleName=role_name,
                    PolicyName=f"{role_name}-policy", 
                    PolicyDocument=json.dumps(permission_policy)
                )
                
                # Í∏∞Î≥∏ Lambda Ïã§Ìñâ Ïó≠Ìï† Ï≤®Î∂Ä
                self.iam_client.attach_role_policy(
                    RoleName=role_name,
                    PolicyArn='arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
                )
                
                return role_arn
                
            except Exception as e:
                if "already exists" in str(e):
                    response = self.iam_client.get_role(RoleName=role_name)
                    role_arn = response['Role']['Arn']
                    logger.info(f"üîÑ Í∏∞Ï°¥ Lambda Ïó≠Ìï† ÏÇ¨Ïö©: {role_name}")
                    return role_arn
                else:
                    raise e
            
        except Exception as e:
            logger.error(f"‚ùå Lambda Ïã§Ìñâ Ïó≠Ìï† ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return ""
    
    def deploy_infrastructure(self) -> Dict[str, Any]:
        """Ï†ÑÏ≤¥ Ïù∏ÌîÑÎùº Î∞∞Ìè¨"""
        try:
            logger.info("üèóÔ∏è Î∂ÑÏÇ∞ Î∞±ÌÖåÏä§ÌåÖ Ïù∏ÌîÑÎùº Ï†ÑÏ≤¥ Î∞∞Ìè¨ ÏãúÏûë")
            deployment_start = datetime.now()
            
            results = {
                "deployment_timestamp": deployment_start.isoformat(),
                "region": self.region,
                "resource_prefix": self.resource_prefix
            }
            
            # 1. SQS ÌÅê ÏãúÏä§ÌÖú Î∞∞Ìè¨
            logger.info("\nüì° 1Îã®Í≥Ñ: SQS ÌÅê ÏãúÏä§ÌÖú Î∞∞Ìè¨")
            sqs_queues = self.deploy_sqs_queues()
            results["sqs_queues"] = sqs_queues
            
            # 2. DynamoDB ÌÖåÏù¥Î∏î Î∞∞Ìè¨
            logger.info("\nüóÑÔ∏è 2Îã®Í≥Ñ: DynamoDB ÌÖåÏù¥Î∏î Î∞∞Ìè¨")
            dynamodb_tables = self.deploy_dynamodb_tables()
            results["dynamodb_tables"] = dynamodb_tables
            
            # 3. Lambda Ïã§Ìñâ Ïó≠Ìï† ÏÉùÏÑ±
            logger.info("\nüîê 3Îã®Í≥Ñ: Lambda Ïã§Ìñâ Ïó≠Ìï† ÏÉùÏÑ±")
            lambda_role_arn = self.create_lambda_execution_role()
            results["lambda_role_arn"] = lambda_role_arn
            
            # Î∞∞Ìè¨ ÏôÑÎ£å ÏãúÍ∞Ñ
            deployment_end = datetime.now()
            deployment_duration = (deployment_end - deployment_start).total_seconds()
            results["deployment_duration_seconds"] = deployment_duration
            
            # Î∞∞Ìè¨ ÏöîÏïΩ
            logger.info(f"\nüéâ Î∂ÑÏÇ∞ Î∞±ÌÖåÏä§ÌåÖ Ïù∏ÌîÑÎùº Î∞∞Ìè¨ ÏôÑÎ£å!")
            logger.info(f"   ‚è±Ô∏è  Î∞∞Ìè¨ ÏÜåÏöî ÏãúÍ∞Ñ: {deployment_duration:.2f}Ï¥à")
            logger.info(f"   üì° SQS ÌÅê: {len(sqs_queues)}Í∞ú")
            logger.info(f"   üóÑÔ∏è  DynamoDB ÌÖåÏù¥Î∏î: {len(dynamodb_tables)}Í∞ú")
            logger.info(f"   üîê Lambda Ïó≠Ìï†: {'ÏÉùÏÑ±Îê®' if lambda_role_arn else 'Ïã§Ìå®'}")
            
            return results
            
        except Exception as e:
            logger.error(f"‚ùå Ïù∏ÌîÑÎùº Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            return {"error": str(e)}

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("üöÄ Î∂ÑÏÇ∞ Î∞±ÌÖåÏä§ÌåÖ Ïù∏ÌîÑÎùº Î∞∞Ìè¨ ÏãúÏûë")
    print("=" * 80)
    
    try:
        # Ïù∏ÌîÑÎùº Î∞∞Ìè¨ Ïã§Ìñâ
        infrastructure = DistributedBacktestingInfrastructure()
        results = infrastructure.deploy_infrastructure()
        
        if "error" not in results:
            print("\n‚úÖ Phase 1: ÌïµÏã¨ Ïù∏ÌîÑÎùº Íµ¨Ï∂ï ÏôÑÎ£å!")
            print("üìã Î∞∞Ìè¨Îêú Î¶¨ÏÜåÏä§:")
            
            # SQS ÌÅê Î™©Î°ù
            if results.get("sqs_queues"):
                print(f"   üì° SQS ÌÅê ({len(results['sqs_queues'])}Í∞ú):")
                for queue_name in results["sqs_queues"].keys():
                    print(f"      ‚Ä¢ {queue_name}")
            
            # DynamoDB ÌÖåÏù¥Î∏î Î™©Î°ù
            if results.get("dynamodb_tables"):
                print(f"   üóÑÔ∏è  DynamoDB ÌÖåÏù¥Î∏î ({len(results['dynamodb_tables'])}Í∞ú):")
                for table_name in results["dynamodb_tables"].keys():
                    print(f"      ‚Ä¢ {table_name}")
            
            # Lambda Ïó≠Ìï†
            if results.get("lambda_role_arn"):
                role_name = results["lambda_role_arn"].split("/")[-1]
                print(f"   üîê Lambda Ïã§Ìñâ Ïó≠Ìï†: {role_name}")
            
            print(f"\nüéØ Îã§Ïùå Îã®Í≥Ñ: Phase 2 - Î∂ÑÏÇ∞ Ï≤òÎ¶¨ ÏóîÏßÑ Í∞úÎ∞ú")
            
        else:
            print(f"‚ùå Ïù∏ÌîÑÎùº Î∞∞Ìè¨ Ïã§Ìå®: {results['error']}")
    
    except Exception as e:
        print(f"‚ùå Ï†ÑÏ≤¥ Î∞∞Ìè¨ Ïã§Ìå®: {e}")

if __name__ == "__main__":
    main()