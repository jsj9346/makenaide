#!/usr/bin/env python3
"""
üìä PhaseÎ≥Ñ Ï†ÑÏö© Ï†ÑÎûµ ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ± Î∞è S3 Ï†ÄÏû•
- Í∞Å PhaseÎ≥ÑÎ°ú ÌäπÌôîÎêú ÏãúÍ∞ÑÎåÄ Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ±
- S3Ïóê ÏûêÎèô Î∞∞Ìè¨ÌïòÏó¨ Lambda Ìï®ÏàòÎì§Ïù¥ ÏùΩÏùÑ Ïàò ÏûàÎèÑÎ°ù Íµ¨ÏÑ±
- ÏãúÍ∞ÑÎåÄ Î∂ÑÏÑùÏùÑ ÌôúÏö©Ìïú ÎèôÏ†Å Í±∞Îûò ÌååÎùºÎØ∏ÌÑ∞ Ï†úÍ≥µ
"""

import boto3
import json
import logging
from datetime import datetime
from typing import Dict, List
import sys
import os

# timezone_strategy_enhancer Î™®Îìà Î°úÎìú
try:
    from timezone_strategy_enhancer import TimezoneStrategyEnhancer, create_strategy_for_phase
    STRATEGY_ENHANCER_AVAILABLE = True
except ImportError:
    STRATEGY_ENHANCER_AVAILABLE = False

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PhaseStrategyConfigBuilder:
    """PhaseÎ≥Ñ Ï†ÑÏö© Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        self.s3_client = boto3.client('s3')
        self.s3_bucket = 'makenaide-bucket-901361833359'
        
        # PhaseÎ≥Ñ ÏÑ§Ï†ï
        self.phase_configs = {
            'scanner': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'scan_interval_minutes': 5,
                    'volatility_threshold': 0.03,
                    'volume_spike_threshold': 1.5,
                    'max_scan_symbols': 50,
                    'breakout_confirmation_candles': 2
                },
                'description': 'Ticker Scanner - ÏãúÏû• Ïä§Ï∫î Î∞è Ï¢ÖÎ™© Î∞úÍµ¥'
            },
            'data_collector': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'collection_interval_minutes': 1,
                    'data_retention_hours': 48,
                    'indicators_to_calculate': ['RSI', 'MACD', 'BB', 'ADX', 'STOCH'],
                    'timeframes': ['1m', '5m', '15m', '1h', '4h', '1d'],
                    'data_validation': True
                },
                'description': 'Data Collector - Ïã§ÏãúÍ∞Ñ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë'
            },
            'filter_phase2': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'filter_criteria': {
                        'min_volume_24h': 1000000000,  # 10ÏñµÏõê Ïù¥ÏÉÅ
                        'min_price_change': 0.02,      # 2% Ïù¥ÏÉÅ Î≥ÄÎèô
                        'rsi_range': [30, 70],
                        'volume_spike_min': 1.3
                    },
                    'ranking_weights': {
                        'volume': 0.3,
                        'momentum': 0.25,
                        'volatility': 0.2,
                        'technical': 0.25
                    }
                },
                'description': 'Comprehensive Filter - Ï¢ÖÌï© ÌïÑÌÑ∞ÎßÅ Î∞è Ï¢ÖÎ™© ÏÑ†Î≥Ñ'
            },
            'gpt_analysis_phase3': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'analysis_depth': 'comprehensive',
                    'market_sentiment_weight': 0.3,
                    'technical_analysis_weight': 0.4,
                    'fundamental_weight': 0.3,
                    'news_analysis_enabled': True,
                    'confidence_threshold': 0.7
                },
                'description': 'GPT Analysis - AI Í∏∞Î∞ò ÏãúÏû• Î∂ÑÏÑù Î∞è ÏòàÏ∏°'
            },
            'analysis_4h_phase4': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'analysis_timeframe': '4h',
                    'trend_confirmation_periods': 3,
                    'support_resistance_levels': 5,
                    'pattern_recognition': True,
                    'volume_profile_analysis': True
                },
                'description': '4H Analysis - 4ÏãúÍ∞Ñ Ï∞®Ìä∏ Í∏∞Ïà†Ï†Å Î∂ÑÏÑù'
            },
            'condition_check_phase5': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'entry_conditions': {
                        'min_confidence': 0.75,
                        'max_risk_per_trade': 0.02,
                        'market_condition_required': 'BULL_OR_NEUTRAL',
                        'position_correlation_max': 0.7
                    },
                    'risk_checks': [
                        'portfolio_correlation',
                        'position_sizing',
                        'market_condition',
                        'volatility_check'
                    ]
                },
                'description': 'Condition Check - ÏßÑÏûÖ Ï°∞Í±¥ Î∞è Î¶¨Ïä§ÌÅ¨ Í≤ÄÏ¶ù'
            },
            'trade_execution_phase6': {
                'base_amount': 1000000,
                'entry_price': 159348000,
                'phase_specific': {
                    'execution_strategy': 'TWAP',  # Time Weighted Average Price
                    'slippage_tolerance': 0.002,
                    'max_execution_time_minutes': 10,
                    'partial_fill_acceptable': True,
                    'order_splitting': {
                        'enabled': True,
                        'max_chunks': 5,
                        'time_interval_seconds': 30
                    }
                },
                'description': 'Trade Execution - Ïã§Ï†ú Í±∞Îûò Ïã§Ìñâ Î∞è Ï≤¥Í≤∞ Í¥ÄÎ¶¨'
            }
        }
    
    def get_current_btc_price(self) -> float:
        """ÌòÑÏû¨ BTC Í∞ÄÍ≤© Ï°∞Ìöå"""
        try:
            import urllib3
            http = urllib3.PoolManager()
            response = http.request('GET', 'https://api.upbit.com/v1/ticker?markets=KRW-BTC')
            
            if response.status == 200:
                data = json.loads(response.data.decode('utf-8'))[0]
                return float(data['trade_price'])
            else:
                logger.warning("BTC Í∞ÄÍ≤© Ï°∞Ìöå Ïã§Ìå® - Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                return 159348000
                
        except Exception as e:
            logger.warning(f"BTC Í∞ÄÍ≤© Ï°∞Ìöå Ï§ë Ïò§Î•ò: {e}")
            return 159348000
    
    def create_phase_strategy_config(self, phase_name: str) -> Dict:
        """ÌäπÏ†ï PhaseÎ•º ÏúÑÌïú Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ±"""
        try:
            if phase_name not in self.phase_configs:
                logger.error(f"Ïïå Ïàò ÏóÜÎäî Phase: {phase_name}")
                return None
            
            phase_config = self.phase_configs[phase_name]
            current_btc_price = self.get_current_btc_price()
            
            logger.info(f"üìä {phase_name} Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± Ï§ë... (BTC: {current_btc_price:,.0f})")
            
            # Í∏∞Î≥∏ Ï†ÑÎûµ ÏÑ§Ï†ï
            if STRATEGY_ENHANCER_AVAILABLE:
                try:
                    enhancer = TimezoneStrategyEnhancer()
                    
                    # ÎèôÏ†Å Ï†ÑÎûµ ÏÉùÏÑ±
                    strategy_config = enhancer.generate_comprehensive_strategy_config(
                        entry_price=current_btc_price,
                        base_amount=phase_config['base_amount'],
                        market_volatility=0.05
                    )
                    
                    # PhaseÎ≥Ñ ÌäπÌôî ÏÑ§Ï†ï Ï∂îÍ∞Ä
                    strategy_config['phase_specific'] = phase_config['phase_specific']
                    strategy_config['phase_info'] = {
                        'phase_name': phase_name,
                        'description': phase_config['description'],
                        'btc_price_at_config': current_btc_price
                    }
                    
                    logger.info(f"‚úÖ {phase_name} ÎèôÏ†Å Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± ÏôÑÎ£å")
                    
                except Exception as e:
                    logger.warning(f"ÎèôÏ†Å Ï†ÑÎûµ ÏÉùÏÑ± Ïã§Ìå® ({phase_name}): {e}")
                    strategy_config = self._create_fallback_strategy(phase_name, current_btc_price)
            else:
                logger.warning(f"TimezoneStrategyEnhancer ÏóÜÏùå - {phase_name} Í∏∞Î≥∏ Ï†ÑÎûµ ÏÇ¨Ïö©")
                strategy_config = self._create_fallback_strategy(phase_name, current_btc_price)
            
            return strategy_config
            
        except Exception as e:
            logger.error(f"Phase Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± Ïã§Ìå® ({phase_name}): {e}")
            return None
    
    def _create_fallback_strategy(self, phase_name: str, btc_price: float) -> Dict:
        """Í∏∞Î≥∏ Ï†ÑÎûµ ÏÑ§Ï†ï (TimezoneStrategyEnhancer ÏóÜÏùÑ Îïå)"""
        phase_config = self.phase_configs[phase_name]
        
        return {
            'position_management': {
                'position_size_krw': phase_config['base_amount'] * 0.5,
                'position_ratio': 0.5,
                'max_risk_per_trade': phase_config['base_amount'] * 0.02
            },
            'risk_management': {
                'stop_loss': {
                    'stop_loss_price': btc_price * 0.92,
                    'stop_loss_percentage': 8.0,
                    'trailing_stop_activation': btc_price * 1.15,
                    'trailing_stop_percentage': 6.0,
                    'reason': "Í∏∞Î≥∏ ÏÑ§Ï†ï (8% ÏÜêÏ†à)"
                },
                'take_profit_levels': [
                    {'level': 1, 'target_price': btc_price * 1.15, 'target_percentage': 15.0, 'quantity_ratio': 0.3},
                    {'level': 2, 'target_price': btc_price * 1.30, 'target_percentage': 30.0, 'quantity_ratio': 0.4},
                    {'level': 3, 'target_price': btc_price * 1.50, 'target_percentage': 50.0, 'quantity_ratio': 0.3}
                ],
                'max_holding_hours': 24
            },
            'market_context': {
                'global_activity_score': 50,
                'dominant_region': 'Asia',
                'trading_style': 'momentum_driven',
                'market_volatility': 0.05
            },
            'execution_params': {
                'entry_price': btc_price,
                'slippage_tolerance': 0.002,
                'partial_fill_acceptable': True,
                'market_order_threshold': 0.001
            },
            'phase_specific': phase_config['phase_specific'],
            'phase_info': {
                'phase_name': phase_name,
                'description': phase_config['description'],
                'btc_price_at_config': btc_price
            },
            'metadata': {
                'strategy_version': '2.1-fallback',
                'config_generated_at': datetime.utcnow().isoformat(),
                'timezone_strategy_available': False
            }
        }
    
    def save_strategy_to_s3(self, phase_name: str, strategy_config: Dict) -> bool:
        """Ï†ÑÎûµ ÏÑ§Ï†ïÏùÑ S3Ïóê Ï†ÄÏû•"""
        try:
            timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
            
            # ÌòÑÏû¨ ÏÑ§Ï†ï ÌååÏùº
            current_key = f'trading_strategy/current_{phase_name}_config.json'
            self.s3_client.put_object(
                Bucket=self.s3_bucket,
                Key=current_key,
                Body=json.dumps(strategy_config, ensure_ascii=False, indent=2),
                ContentType='application/json'
            )
            
            # Î∞±ÏóÖ ÌååÏùº
            backup_key = f'trading_strategy/history/{phase_name}_config_{timestamp}.json'
            self.s3_client.put_object(
                Bucket=self.s3_bucket,
                Key=backup_key,
                Body=json.dumps(strategy_config, ensure_ascii=False, indent=2),
                ContentType='application/json'
            )
            
            logger.info(f"‚úÖ {phase_name} Ï†ÑÎûµ ÏÑ§Ï†ï S3 Ï†ÄÏû• ÏôÑÎ£å")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå {phase_name} Ï†ÑÎûµ ÏÑ§Ï†ï S3 Ï†ÄÏû• Ïã§Ìå®: {e}")
            return False
    
    def create_all_phase_configs(self) -> Dict[str, bool]:
        """Î™®Îì† PhaseÎ≥Ñ Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± Î∞è Ï†ÄÏû•"""
        logger.info("üöÄ PhaseÎ≥Ñ Ï†ÑÏö© Ï†ÑÎûµ ÏÑ§Ï†ï ÏùºÍ¥Ñ ÏÉùÏÑ± ÏãúÏûë")
        logger.info("=" * 80)
        
        results = {}
        
        for phase_name in self.phase_configs.keys():
            logger.info(f"\nüìä {phase_name} Ï≤òÎ¶¨ Ï§ë...")
            
            # Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ±
            strategy_config = self.create_phase_strategy_config(phase_name)
            if not strategy_config:
                results[phase_name] = False
                continue
            
            # S3Ïóê Ï†ÄÏû•
            save_success = self.save_strategy_to_s3(phase_name, strategy_config)
            results[phase_name] = save_success
            
            if save_success:
                # Ï£ºÏöî Ï†ïÎ≥¥ Î°úÍπÖ
                pos_size = strategy_config['position_management']['position_size_krw']
                stop_loss = strategy_config['risk_management']['stop_loss']['stop_loss_percentage']
                
                logger.info(f"‚úÖ {phase_name} ÏôÑÎ£å - Ìè¨ÏßÄÏÖò: {pos_size:,.0f}KRW, ÏÜêÏ†à: {stop_loss:.1f}%")
        
        # Í≤∞Í≥º ÏöîÏïΩ
        success_count = sum(results.values())
        total_count = len(results)
        
        logger.info("=" * 80)
        logger.info(f"üéØ Phase Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± ÏôÑÎ£å: {success_count}/{total_count}")
        
        print(f"""
üìä PhaseÎ≥Ñ Ï†ÑÏö© Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± ÏôÑÎ£å!

üìà ÏÉùÏÑ± Í≤∞Í≥º:
   ‚Ä¢ Ï¥ù Phase: {total_count}Í∞ú
   ‚Ä¢ ÏÑ±Í≥µ: {success_count}Í∞ú
   ‚Ä¢ Ïã§Ìå®: {total_count - success_count}Í∞ú

üîç ÏÉÅÏÑ∏ Í≤∞Í≥º:
{chr(10).join(f'   ‚Ä¢ {phase}: {"‚úÖ ÏÑ±Í≥µ" if status else "‚ùå Ïã§Ìå®"}' for phase, status in results.items())}

üåè Ï†ÑÎûµ ÏÑ§Ï†ï ÌäπÏßï:
   ‚Ä¢ ÏãúÍ∞ÑÎåÄ Î∂ÑÏÑù Í∏∞Î∞ò ÎèôÏ†Å ÌååÎùºÎØ∏ÌÑ∞ Ï°∞Ï†ï
   ‚Ä¢ PhaseÎ≥Ñ ÌäπÌôîÎêú Í±∞Îûò Î°úÏßÅ ÏÑ§Ï†ï
   ‚Ä¢ S3 ÏûêÎèô Ï†ÄÏû•ÏúºÎ°ú Lambda Ìï®Ïàò Ïó∞Îèô
   ‚Ä¢ Ïã§ÏãúÍ∞Ñ ÏãúÏû• ÏÉÅÌô© Î∞òÏòÅ

üìÇ S3 Ï†ÄÏû• ÏúÑÏπò:
   ‚Ä¢ ÌòÑÏû¨ ÏÑ§Ï†ï: s3://{self.s3_bucket}/trading_strategy/current_{{phase}}_config.json
   ‚Ä¢ ÌûàÏä§ÌÜ†Î¶¨: s3://{self.s3_bucket}/trading_strategy/history/{{phase}}_config_{{timestamp}}.json

üéØ Îã§Ïùå Îã®Í≥Ñ:
   ‚Ä¢ Lambda Ìï®ÏàòÎì§Ïù¥ S3ÏóêÏÑú Ï†ÑÎûµ ÏÑ§Ï†ï Î°úÎìú
   ‚Ä¢ EventBridge Ïä§ÏºÄÏ§Ñ Ïã§Ìñâ Ïãú ÏûêÎèô Ï†ÅÏö©
   ‚Ä¢ ÏãúÍ∞ÑÎåÄÎ≥Ñ Ï†ÑÎûµ Í∞±Ïã† Î™®ÎãàÌÑ∞ÎßÅ
        """)
        
        return results
    
    def create_master_strategy_index(self) -> bool:
        """ÎßàÏä§ÌÑ∞ Ï†ÑÎûµ Ïù∏Îç±Ïä§ ÌååÏùº ÏÉùÏÑ±"""
        try:
            logger.info("üìã ÎßàÏä§ÌÑ∞ Ï†ÑÎûµ Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ï§ë...")
            
            index = {
                'last_updated': datetime.utcnow().isoformat(),
                'timezone_strategy_available': STRATEGY_ENHANCER_AVAILABLE,
                'phases': {},
                'global_settings': {
                    'base_amount_default': 1000000,
                    'strategy_refresh_hours': 6,
                    'risk_per_trade_max': 0.02,
                    'max_concurrent_positions': 3
                }
            }
            
            # Í∞Å Phase Ï†ïÎ≥¥ ÏàòÏßë
            for phase_name, config in self.phase_configs.items():
                index['phases'][phase_name] = {
                    'description': config['description'],
                    'config_file': f'trading_strategy/current_{phase_name}_config.json',
                    'last_updated': datetime.utcnow().isoformat(),
                    'phase_specific_keys': list(config['phase_specific'].keys())
                }
            
            # S3Ïóê Ï†ÄÏû•
            self.s3_client.put_object(
                Bucket=self.s3_bucket,
                Key='trading_strategy/master_index.json',
                Body=json.dumps(index, ensure_ascii=False, indent=2),
                ContentType='application/json'
            )
            
            logger.info("‚úÖ ÎßàÏä§ÌÑ∞ Ï†ÑÎûµ Ïù∏Îç±Ïä§ ÏÉùÏÑ± ÏôÑÎ£å")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå ÎßàÏä§ÌÑ∞ Ï†ÑÎûµ Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return False

def main():
    """Î©îÏù∏ Ïã§Ìñâ"""
    builder = PhaseStrategyConfigBuilder()
    
    # PhaseÎ≥Ñ Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ±
    results = builder.create_all_phase_configs()
    
    # ÎßàÏä§ÌÑ∞ Ïù∏Îç±Ïä§ ÏÉùÏÑ±
    index_success = builder.create_master_strategy_index()
    
    success_count = sum(results.values())
    total_count = len(results)
    
    if success_count >= total_count * 0.8 and index_success:
        print("üéâ PhaseÎ≥Ñ Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± ÏÑ±Í≥µ!")
        exit(0)
    else:
        print("‚ö†Ô∏è ÏùºÎ∂Ä Phase Ï†ÑÎûµ ÏÑ§Ï†ï ÏÉùÏÑ± Ïã§Ìå®!")
        exit(1)

if __name__ == '__main__':
    main()