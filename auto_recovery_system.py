"""
Auto Recovery System for Makenaide Data Issues
ÏûêÎèô Îç∞Ïù¥ÌÑ∞ Î≥µÍµ¨ ÏãúÏä§ÌÖú

Ï£ºÏöî Í∏∞Îä•:
1. 0Í∞í OHLCV Îç∞Ïù¥ÌÑ∞ ÏûêÎèô Î≥µÍµ¨
2. Static Indicators Ïû¨Í≥ÑÏÇ∞ Î∞è ÏóÖÎç∞Ïù¥Ìä∏
3. ÎÖºÎ¶¨Ï†Å Ïò§Î•ò Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï
4. ÎàÑÎùΩÎêú Îç∞Ïù¥ÌÑ∞ Î≥¥ÏôÑ
5. Î≥µÍµ¨ Í≥ºÏ†ï Î°úÍπÖ Î∞è Í≤ÄÏ¶ù
"""

import asyncio
import logging
import traceback
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import pyupbit
import pandas as pd
import numpy as np
from utils import get_db_connection
from psycopg2.extras import RealDictCursor
import time
import json

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class RecoveryResult:
    """Î≥µÍµ¨ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    recovery_type: str
    ticker: str
    affected_records: int
    success: bool
    error_message: Optional[str]
    duration_seconds: float
    timestamp: datetime

class AutoRecoverySystem:
    """ÏûêÎèô Îç∞Ïù¥ÌÑ∞ Î≥µÍµ¨ ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        self.recovery_results = []
        # API ÌÇ§Í∞Ä ÌïÑÏöîÌïòÏßÄ ÏïäÏùÄ Í≥µÍ∞ú Ìï®ÏàòÎßå ÏÇ¨Ïö©
        
        # Î≥µÍµ¨ ÌÜµÍ≥Ñ
        self.stats = {
            'total_attempts': 0,
            'successful_recoveries': 0,
            'failed_recoveries': 0,
            'zero_values_fixed': 0,
            'static_indicators_recalculated': 0,
            'logical_errors_fixed': 0
        }
        
    def log_recovery_result(self, result: RecoveryResult):
        """Î≥µÍµ¨ Í≤∞Í≥º Î°úÍπÖ"""
        self.recovery_results.append(result)
        
        if result.success:
            self.stats['successful_recoveries'] += 1
            logger.info(f"‚úÖ {result.recovery_type} Î≥µÍµ¨ ÏÑ±Í≥µ: {result.ticker} ({result.affected_records}Í±¥)")
        else:
            self.stats['failed_recoveries'] += 1
            logger.error(f"‚ùå {result.recovery_type} Î≥µÍµ¨ Ïã§Ìå®: {result.ticker} - {result.error_message}")
        
        self.stats['total_attempts'] += 1
    
    def fix_zero_ohlcv_values(self, ticker: str, limit_days: int = 30) -> RecoveryResult:
        """0Í∞í OHLCV Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï"""
        start_time = time.time()
        
        try:
            conn = get_db_connection()
            cursor = conn.cursor(cursor_factory=RealDictCursor)
            
            # 0Í∞í Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞
            cursor.execute("""
                SELECT date, open, high, low, close, volume
                FROM ohlcv 
                WHERE ticker = %s 
                  AND (open = 0 OR high = 0 OR low = 0 OR close = 0)
                  AND date >= CURRENT_DATE - INTERVAL '%s days'
                ORDER BY date
            """, (ticker, limit_days))
            
            zero_records = cursor.fetchall()
            
            if not zero_records:
                cursor.close()
                conn.close()
                return RecoveryResult(
                    recovery_type="zero_ohlcv_fix",
                    ticker=ticker,
                    affected_records=0,
                    success=True,
                    error_message=None,
                    duration_seconds=time.time() - start_time,
                    timestamp=datetime.now()
                )
            
            logger.info(f"üîß {ticker}: {len(zero_records)}Í∞ú 0Í∞í Î†àÏΩîÎìú Î≥µÍµ¨ ÏãúÏûë")
            
            fixed_count = 0
            
            for record in zero_records:
                date = record['date']
                
                try:
                    # PyUpbitÏóêÏÑú Ìï¥Îãπ ÎÇ†ÏßúÏùò Ïò¨Î∞îÎ•∏ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
                    df = pyupbit.get_ohlcv(ticker, interval="day", count=1, to=date.strftime('%Y%m%d'))
                    
                    if df is not None and not df.empty:
                        # Ï≤´ Î≤àÏß∏ ÌñâÏùò Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                        row = df.iloc[0]
                        
                        # 0Ïù¥ ÏïÑÎãå Í∞íÎì§Îßå ÏóÖÎç∞Ïù¥Ìä∏
                        update_fields = []
                        update_values = []
                        
                        if record['open'] == 0 and row['open'] > 0:
                            update_fields.append("open = %s")
                            update_values.append(float(row['open']))
                        
                        if record['high'] == 0 and row['high'] > 0:
                            update_fields.append("high = %s")
                            update_values.append(float(row['high']))
                        
                        if record['low'] == 0 and row['low'] > 0:
                            update_fields.append("low = %s")
                            update_values.append(float(row['low']))
                        
                        if record['close'] == 0 and row['close'] > 0:
                            update_fields.append("close = %s")
                            update_values.append(float(row['close']))
                        
                        if update_fields:
                            update_values.extend([ticker, date])
                            update_query = f"""
                                UPDATE ohlcv 
                                SET {', '.join(update_fields)}, updated_at = CURRENT_TIMESTAMP
                                WHERE ticker = %s AND date = %s
                            """
                            
                            cursor.execute(update_query, update_values)
                            fixed_count += 1
                            
                            logger.debug(f"‚úÖ {ticker} {date}: 0Í∞í Îç∞Ïù¥ÌÑ∞ Î≥µÍµ¨Îê®")
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {ticker} {date} Î≥µÍµ¨ Ïã§Ìå®: {e}")
                    continue
                
                # API Ìò∏Ï∂ú Ï†úÌïú Î∞©ÏßÄ
                time.sleep(0.1)
            
            conn.commit()
            cursor.close()
            conn.close()
            
            self.stats['zero_values_fixed'] += fixed_count
            
            return RecoveryResult(
                recovery_type="zero_ohlcv_fix",
                ticker=ticker,
                affected_records=fixed_count,
                success=True,
                error_message=None,
                duration_seconds=time.time() - start_time,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            return RecoveryResult(
                recovery_type="zero_ohlcv_fix",
                ticker=ticker,
                affected_records=0,
                success=False,
                error_message=str(e),
                duration_seconds=time.time() - start_time,
                timestamp=datetime.now()
            )
    
    def recalculate_static_indicators(self, ticker: str) -> RecoveryResult:
        """Static Indicators Ïû¨Í≥ÑÏÇ∞"""
        start_time = time.time()
        
        try:
            # data_fetcherÏóêÏÑú Í≥ÑÏÇ∞ Ìï®Ïàò import
            from data_fetcher import calculate_static_indicators
            
            conn = get_db_connection()
            cursor = conn.cursor(cursor_factory=RealDictCursor)
            
            # ÌòÑÏû¨ static indicators Í∞ÄÏ†∏Ïò§Í∏∞
            cursor.execute("SELECT * FROM static_indicators WHERE ticker = %s", (ticker,))
            current_static = cursor.fetchone()
            
            if not current_static:
                cursor.close()
                conn.close()
                return RecoveryResult(
                    recovery_type="static_indicators_recalc",
                    ticker=ticker,
                    affected_records=0,
                    success=False,
                    error_message="Static indicators record not found",
                    duration_seconds=time.time() - start_time,
                    timestamp=datetime.now()
                )
            
            # OHLCV Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (ÏµúÍ∑º 200Ïùº)
            cursor.execute("""
                SELECT date, open, high, low, close, volume
                FROM ohlcv 
                WHERE ticker = %s
                ORDER BY date DESC
                LIMIT 200
            """, (ticker,))
            
            ohlcv_data = cursor.fetchall()
            
            if len(ohlcv_data) < 30:  # ÏµúÏÜå 30Ïùº Îç∞Ïù¥ÌÑ∞ ÌïÑÏöî
                cursor.close()
                conn.close()
                return RecoveryResult(
                    recovery_type="static_indicators_recalc",
                    ticker=ticker,
                    affected_records=0,
                    success=False,
                    error_message="Insufficient OHLCV data for calculation",
                    duration_seconds=time.time() - start_time,
                    timestamp=datetime.now()
                )
            
            # DataFrameÏúºÎ°ú Î≥ÄÌôò
            df = pd.DataFrame(ohlcv_data)
            df = df.sort_values('date').reset_index(drop=True)
            df.set_index('date', inplace=True)
            
            # Static indicators Ïû¨Í≥ÑÏÇ∞
            new_indicators = calculate_static_indicators(df, ticker)
            
            if new_indicators:
                # ÏóÖÎç∞Ïù¥Ìä∏ ÏøºÎ¶¨ Ïã§Ìñâ
                cursor.execute("""
                    UPDATE static_indicators 
                    SET 
                        ma200_slope = %s,
                        nvt_relative = %s,
                        volume_change_7_30 = %s,
                        adx = %s,
                        supertrend_signal = %s,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE ticker = %s
                """, (
                    new_indicators.get('ma200_slope'),
                    new_indicators.get('nvt_relative'),
                    new_indicators.get('volume_change_7_30'),
                    new_indicators.get('adx'),
                    new_indicators.get('supertrend_signal'),
                    ticker
                ))
                
                conn.commit()
                
                logger.info(f"‚úÖ {ticker} Static indicators Ïû¨Í≥ÑÏÇ∞ ÏôÑÎ£å")
                self.stats['static_indicators_recalculated'] += 1
                
                cursor.close()
                conn.close()
                
                return RecoveryResult(
                    recovery_type="static_indicators_recalc",
                    ticker=ticker,
                    affected_records=1,
                    success=True,
                    error_message=None,
                    duration_seconds=time.time() - start_time,
                    timestamp=datetime.now()
                )
            else:
                cursor.close()
                conn.close()
                return RecoveryResult(
                    recovery_type="static_indicators_recalc",
                    ticker=ticker,
                    affected_records=0,
                    success=False,
                    error_message="Failed to calculate new indicators",
                    duration_seconds=time.time() - start_time,
                    timestamp=datetime.now()
                )
                
        except Exception as e:
            return RecoveryResult(
                recovery_type="static_indicators_recalc",
                ticker=ticker,
                affected_records=0,
                success=False,
                error_message=str(e),
                duration_seconds=time.time() - start_time,
                timestamp=datetime.now()
            )
    
    def fix_logical_errors(self, ticker: str, limit_days: int = 30) -> RecoveryResult:
        """ÎÖºÎ¶¨Ï†Å Ïò§Î•ò ÏàòÏ†ï (high < low, close > high Îì±)"""
        start_time = time.time()
        
        try:
            conn = get_db_connection()
            cursor = conn.cursor(cursor_factory=RealDictCursor)
            
            # ÎÖºÎ¶¨Ï†Å Ïò§Î•ò Ï∞æÍ∏∞
            cursor.execute("""
                SELECT date, open, high, low, close, volume
                FROM ohlcv 
                WHERE ticker = %s 
                  AND date >= CURRENT_DATE - INTERVAL '%s days'
                  AND (high < low OR close > high OR close < low OR open > high OR open < low)
                ORDER BY date
            """, (ticker, limit_days))
            
            error_records = cursor.fetchall()
            
            if not error_records:
                cursor.close()
                conn.close()
                return RecoveryResult(
                    recovery_type="logical_errors_fix",
                    ticker=ticker,
                    affected_records=0,
                    success=True,
                    error_message=None,
                    duration_seconds=time.time() - start_time,
                    timestamp=datetime.now()
                )
            
            logger.info(f"üîß {ticker}: {len(error_records)}Í∞ú ÎÖºÎ¶¨ Ïò§Î•ò Î†àÏΩîÎìú Î≥µÍµ¨ ÏãúÏûë")
            
            fixed_count = 0
            
            for record in error_records:
                date = record['date']
                
                try:
                    # PyUpbitÏóêÏÑú Ïò¨Î∞îÎ•∏ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
                    df = pyupbit.get_ohlcv(ticker, interval="day", count=1, to=date.strftime('%Y%m%d'))
                    
                    if df is not None and not df.empty:
                        row = df.iloc[0]
                        
                        # ÎÖºÎ¶¨Ï†ÅÏúºÎ°ú Ïò¨Î∞îÎ•∏ Í∞íÏù∏ÏßÄ ÌôïÏù∏
                        if (row['low'] <= row['open'] <= row['high'] and 
                            row['low'] <= row['close'] <= row['high'] and
                            row['low'] <= row['high']):
                            
                            cursor.execute("""
                                UPDATE ohlcv 
                                SET 
                                    open = %s,
                                    high = %s,
                                    low = %s,
                                    close = %s,
                                    updated_at = CURRENT_TIMESTAMP
                                WHERE ticker = %s AND date = %s
                            """, (
                                float(row['open']),
                                float(row['high']),
                                float(row['low']),
                                float(row['close']),
                                ticker,
                                date
                            ))
                            
                            fixed_count += 1
                            logger.debug(f"‚úÖ {ticker} {date}: ÎÖºÎ¶¨ Ïò§Î•ò ÏàòÏ†ïÎê®")
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {ticker} {date} ÎÖºÎ¶¨ Ïò§Î•ò ÏàòÏ†ï Ïã§Ìå®: {e}")
                    continue
                
                time.sleep(0.1)  # API Ìò∏Ï∂ú Ï†úÌïú
            
            conn.commit()
            cursor.close()
            conn.close()
            
            self.stats['logical_errors_fixed'] += fixed_count
            
            return RecoveryResult(
                recovery_type="logical_errors_fix",
                ticker=ticker,
                affected_records=fixed_count,
                success=True,
                error_message=None,
                duration_seconds=time.time() - start_time,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            return RecoveryResult(
                recovery_type="logical_errors_fix",
                ticker=ticker,
                affected_records=0,
                success=False,
                error_message=str(e),
                duration_seconds=time.time() - start_time,
                timestamp=datetime.now()
            )
    
    def auto_recover_ticker(self, ticker: str) -> List[RecoveryResult]:
        """ÌäπÏ†ï Ìã∞Ïª§Ïùò Î™®Îì† Î¨∏Ï†ú ÏûêÎèô Î≥µÍµ¨"""
        logger.info(f"üîß {ticker} ÏûêÎèô Î≥µÍµ¨ ÏãúÏûë")
        
        results = []
        
        # 1. 0Í∞í OHLCV Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï
        result1 = self.fix_zero_ohlcv_values(ticker)
        results.append(result1)
        self.log_recovery_result(result1)
        
        # 2. ÎÖºÎ¶¨Ï†Å Ïò§Î•ò ÏàòÏ†ï
        result2 = self.fix_logical_errors(ticker)
        results.append(result2)
        self.log_recovery_result(result2)
        
        # 3. Static indicators Ïû¨Í≥ÑÏÇ∞ (OHLCV ÏàòÏ†ï ÌõÑ)
        if result1.success or result2.success:
            time.sleep(1)  # Ïû†Ïãú ÎåÄÍ∏∞
            result3 = self.recalculate_static_indicators(ticker)
            results.append(result3)
            self.log_recovery_result(result3)
        
        return results
    
    def recover_all_problematic_tickers(self, limit_tickers: int = 20) -> Dict[str, List[RecoveryResult]]:
        """Î¨∏Ï†úÍ∞Ä ÏûàÎäî Î™®Îì† Ìã∞Ïª§ ÏûêÎèô Î≥µÍµ¨"""
        logger.info("üîß Ï†ÑÏ≤¥ ÏûêÎèô Î≥µÍµ¨ ÏãúÏûë")
        
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            
            # Î¨∏Ï†úÍ∞Ä ÏûàÎäî Ìã∞Ïª§Îì§ Ï∞æÍ∏∞
            cursor.execute("""
                SELECT DISTINCT ticker
                FROM ohlcv 
                WHERE (open = 0 OR high = 0 OR low = 0 OR close = 0
                       OR high < low OR close > high OR close < low 
                       OR open > high OR open < low)
                  AND date >= CURRENT_DATE - INTERVAL '30 days'
                ORDER BY ticker
                LIMIT %s
            """, (limit_tickers,))
            
            problematic_tickers = [row[0] for row in cursor.fetchall()]
            
            # Static indicators Î¨∏Ï†ú Ìã∞Ïª§ÎèÑ Ï∂îÍ∞Ä
            cursor.execute("""
                SELECT ticker FROM static_indicators 
                WHERE ma200_slope = 0.0 AND nvt_relative = 1.0 AND volume_change_7_30 = 1.0
                LIMIT %s
            """, (limit_tickers,))
            
            static_problem_tickers = [row[0] for row in cursor.fetchall()]
            
            cursor.close()
            conn.close()
            
            # Ï§ëÎ≥µ Ï†úÍ±∞
            all_problem_tickers = list(set(problematic_tickers + static_problem_tickers))
            
            logger.info(f"üîç Î≥µÍµ¨ ÎåÄÏÉÅ Ìã∞Ïª§: {len(all_problem_tickers)}Í∞ú")
            
            all_results = {}
            
            for ticker in all_problem_tickers:
                try:
                    results = self.auto_recover_ticker(ticker)
                    all_results[ticker] = results
                    
                    # ÎÑàÎ¨¥ Îπ†Î•∏ API Ìò∏Ï∂ú Î∞©ÏßÄ
                    time.sleep(2)
                    
                except Exception as e:
                    logger.error(f"‚ùå {ticker} Î≥µÍµ¨ Ï§ë Ïò§Î•ò: {e}")
                    all_results[ticker] = [RecoveryResult(
                        recovery_type="full_recovery",
                        ticker=ticker,
                        affected_records=0,
                        success=False,
                        error_message=str(e),
                        duration_seconds=0,
                        timestamp=datetime.now()
                    )]
            
            return all_results
            
        except Exception as e:
            logger.error(f"‚ùå Ï†ÑÏ≤¥ Î≥µÍµ¨ Ï§ë Ïò§Î•ò: {e}")
            return {}
    
    def generate_recovery_report(self, results: Dict[str, List[RecoveryResult]]) -> str:
        """Î≥µÍµ¨ Î≥¥Í≥†ÏÑú ÏÉùÏÑ±"""
        report_lines = []
        report_lines.append("=" * 80)
        report_lines.append("üîß ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú Î≥¥Í≥†ÏÑú")
        report_lines.append(f"üìÖ ÏÉùÏÑ± ÏãúÍ∞Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append("=" * 80)
        
        # Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
        total_tickers = len(results)
        successful_tickers = sum(1 for ticker_results in results.values() 
                               if any(r.success for r in ticker_results))
        
        report_lines.append(f"\nüìä Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ:")
        report_lines.append(f"   Ï≤òÎ¶¨ Ìã∞Ïª§: {total_tickers}Í∞ú")
        report_lines.append(f"   ÏÑ±Í≥µ Ìã∞Ïª§: {successful_tickers}Í∞ú")
        report_lines.append(f"   ÏÑ±Í≥µÎ•†: {successful_tickers/total_tickers:.1%}" if total_tickers > 0 else "   ÏÑ±Í≥µÎ•†: 0%")
        
        # ÏÑ∏Î∂Ä ÌÜµÍ≥Ñ
        report_lines.append(f"\nüìà Î≥µÍµ¨ Ïú†ÌòïÎ≥Ñ ÌÜµÍ≥Ñ:")
        report_lines.append(f"   0Í∞í ÏàòÏ†ï: {self.stats['zero_values_fixed']}Í±¥")
        report_lines.append(f"   ÎÖºÎ¶¨ Ïò§Î•ò ÏàòÏ†ï: {self.stats['logical_errors_fixed']}Í±¥")
        report_lines.append(f"   Static ÏßÄÌëú Ïû¨Í≥ÑÏÇ∞: {self.stats['static_indicators_recalculated']}Í±¥")
        
        # Ìã∞Ïª§Î≥Ñ ÏÉÅÏÑ∏ Í≤∞Í≥º (ÏÑ±Í≥µÌïú Í≤ÉÎì§Îßå)
        if successful_tickers > 0:
            report_lines.append(f"\n‚úÖ ÏÑ±Í≥µÌïú Î≥µÍµ¨ ÏûëÏóÖ:")
            for ticker, ticker_results in results.items():
                successful_results = [r for r in ticker_results if r.success and r.affected_records > 0]
                if successful_results:
                    report_lines.append(f"\n   üìç {ticker}:")
                    for result in successful_results:
                        report_lines.append(f"      ‚úÖ {result.recovery_type}: {result.affected_records}Í±¥ Î≥µÍµ¨")
        
        # Ïã§Ìå®Ìïú Î≥µÍµ¨ ÏûëÏóÖ
        failed_results = []
        for ticker, ticker_results in results.items():
            for result in ticker_results:
                if not result.success:
                    failed_results.append((ticker, result))
        
        if failed_results:
            report_lines.append(f"\n‚ùå Ïã§Ìå®Ìïú Î≥µÍµ¨ ÏûëÏóÖ ({len(failed_results)}Í±¥):")
            for ticker, result in failed_results[:10]:  # ÏµúÎåÄ 10Í∞úÎßå ÌëúÏãú
                report_lines.append(f"   ‚ùå {ticker} - {result.recovery_type}: {result.error_message}")
        
        report_lines.append("=" * 80)
        
        return "\n".join(report_lines)
    
    def save_recovery_report(self, results: Dict[str, List[RecoveryResult]], filename: Optional[str] = None):
        """Î≥µÍµ¨ Î≥¥Í≥†ÏÑú ÌååÏùºÎ°ú Ï†ÄÏû•"""
        if filename is None:
            filename = f"recovery_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        
        report = self.generate_recovery_report(results)
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report)
        
        # JSON ÌòïÌÉúÎ°úÎèÑ Ï†ÄÏû•
        json_filename = filename.replace('.txt', '.json')
        json_data = {
            'timestamp': datetime.now().isoformat(),
            'stats': self.stats,
            'results': {
                ticker: [
                    {
                        'recovery_type': r.recovery_type,
                        'affected_records': r.affected_records,
                        'success': r.success,
                        'error_message': r.error_message,
                        'duration_seconds': r.duration_seconds,
                        'timestamp': r.timestamp.isoformat()
                    } for r in ticker_results
                ] for ticker, ticker_results in results.items()
            }
        }
        
        with open(json_filename, 'w', encoding='utf-8') as f:
            json.dump(json_data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"üìÅ Î≥µÍµ¨ Î≥¥Í≥†ÏÑú Ï†ÄÏû•: {filename}, {json_filename}")

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    recovery_system = AutoRecoverySystem()
    
    print("üîß Makenaide ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú")
    print("=" * 50)
    print("1. Îã®Ïùº Ìã∞Ïª§ Î≥µÍµ¨")
    print("2. Ï†ÑÏ≤¥ ÏûêÎèô Î≥µÍµ¨ (Î¨∏Ï†ú Ìã∞Ïª§Îì§)")
    print("3. 0Í∞í Îç∞Ïù¥ÌÑ∞Îßå Î≥µÍµ¨")
    print("4. Static IndicatorsÎßå Ïû¨Í≥ÑÏÇ∞")
    print("5. Ï¢ÖÎ£å")
    
    while True:
        try:
            choice = input("\nÏÑ†ÌÉùÌïòÏÑ∏Ïöî (1-5): ").strip()
            
            if choice == '1':
                ticker = input("Ìã∞Ïª§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: KRW-BTC): ").strip()
                if ticker:
                    results = recovery_system.auto_recover_ticker(ticker)
                    print("\n" + recovery_system.generate_recovery_report({ticker: results}))
            
            elif choice == '2':
                limit = input("ÏµúÎåÄ Î≥µÍµ¨Ìï† Ìã∞Ïª§ Ïàò (Í∏∞Î≥∏Í∞í: 20): ").strip()
                limit = int(limit) if limit.isdigit() else 20
                
                print(f"üîß ÏµúÎåÄ {limit}Í∞ú Ìã∞Ïª§ ÏûêÎèô Î≥µÍµ¨ ÏãúÏûë...")
                results = recovery_system.recover_all_problematic_tickers(limit)
                
                if results:
                    report = recovery_system.generate_recovery_report(results)
                    print("\n" + report)
                    
                    # Î≥¥Í≥†ÏÑú Ï†ÄÏû•
                    recovery_system.save_recovery_report(results)
                else:
                    print("‚ùå Î≥µÍµ¨Ìï† Ïàò ÏûàÎäî Ìã∞Ïª§Í∞Ä ÏóÜÏäµÎãàÎã§.")
            
            elif choice == '3':
                ticker = input("Ìã∞Ïª§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: KRW-BTC): ").strip()
                if ticker:
                    result = recovery_system.fix_zero_ohlcv_values(ticker)
                    recovery_system.log_recovery_result(result)
                    print(f"\nÍ≤∞Í≥º: {result}")
            
            elif choice == '4':
                ticker = input("Ìã∞Ïª§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: KRW-BTC): ").strip()
                if ticker:
                    result = recovery_system.recalculate_static_indicators(ticker)
                    recovery_system.log_recovery_result(result)
                    print(f"\nÍ≤∞Í≥º: {result}")
            
            elif choice == '5':
                break
            
            else:
                print("‚ùì ÏûòÎ™ªÎêú ÏÑ†ÌÉùÏûÖÎãàÎã§.")
                
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"‚ùå Ïò§Î•ò: {e}")
    
    print("\nüëã ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖúÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.")

if __name__ == "__main__":
    main()
